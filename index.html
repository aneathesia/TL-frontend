<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<meta name="renderer" content="webkit|ie-comp|ie-stand">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
	<meta http-equiv="Cache-Control" content="no-siteapp" />
	<LINK rel="Bookmark" href="/favicon.ico" >
	<LINK rel="Shortcut Icon" href="/favicon.ico" />
	<!--[if lt IE 9]>
    <script type="text/javascript" src="lib/html5.js"></script>
    <script type="text/javascript" src="lib/respond.min.js"></script>
    <script type="text/javascript" src="lib/PIE_IE678.js"></script>
    <![endif]-->
	<link rel="stylesheet" href="https://www.jq22.com/jquery/bootstrap-3.3.4.css">
	<link href="css/H-ui.css" rel="stylesheet" type="text/css" />
	<link href="css/H-ui.min.css" rel="stylesheet" type="text/css" />
	<link href="css/H-ui.admin.css" rel="stylesheet" type="text/css" />
	<link href="skin/default/skin.css" rel="stylesheet" type="text/css" id="skin" />
	<link href="lib/Hui-iconfont/1.0.1/iconfont.css" rel="stylesheet" type="text/css" />
	<link href="css/style.css" rel="stylesheet" type="text/css" />
	<link href="css/xui.css" type="text/css" rel="stylesheet" />
	<link rel="stylesheet" type="text/css" href="css/gm.css"/>
	<link rel="stylesheet" href="https://www.jq22.com/jquery/font-awesome.4.7.0.css">
	<link href="lib/layer/1.9.3/skin/layer.css" rel="stylesheet" type="text/css" />
	<!--[if IE 6]>
    <script type="text/javascript" src="http://lib.h-ui.net/DD_belatedPNG_0.0.8a-min.js" ></script>
    <script>DD_belatedPNG.fix('*');</script>
    <![endif]-->

	<script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>
	<script src="https://cdn.bootcss.com/FileSaver.js/2014-11-29/FileSaver.js"></script>
	<script type="text/javascript" src="lib/jquery/1.9.1/jquery.min.js"></script>
	<script type="text/javascript" src="lib/layer/1.9.3/layer.js"></script>
	<script type="text/javascript" src="./js/H-ui.js"></script>
	<script type="text/javascript" src="./js/H-ui.admin.js"></script>
	<script type="text/javascript" src="./js/movediv.js"></script>
	<script type="text/javascript" src="./js/three.js"></script>
	<script type="text/javascript" src="./js/three.module.js"></script>
	<script type="text/javascript" src="./js/gm.js"></script>
	<script type="text/javascript" src="./config.js"></script>
	<script src="./js/DragControls1.js"></script>
	<script type="text/javascript" src="./js/TL.js"></script>



	<title>架空输电线路勘测设计一体化系统</title>
</head>
<body class="mainbody">
<style>
	@import url(./css/nativestyle.css);
</style>
<header class="Hui-header cl"> <a class="Hui-logo l" title="架空输电线路勘测设计一体化系统" href="#">架空输电线路勘测设计一体化系统</a>
	<nav class="mainnav cl" id="Hui-nav" style="display: none">
		<ul>
			<li class="dropDown dropDown_click">
				<a href="javascript:;" class="dropDown_A">
					<input type="button" style="display:inline-block" id="newprj" value="新建工程" />
					<i class="Hui-iconfont">   &#xe642;</i>
					<input type="file" style="display:inline-block;" id="file" name="myfile" class="uploadfile"/>
					<input type="button" style="display:inline-block" id="upload" onclick="upfile()" value="上传" />
					<input type="button" style="display:inline-block" id="cancel" onclick="cancelUploadFile()" value="取消" />
					<input type="button" style="display:inline-block" id="filelist" onclick="getFilelist()" value="获取文件列表" />
					<select id="fileDirectory" >
						<option>请选择文件</option>
					</select>
					<button type="button" id="openBeFile" onclick="openBeFile()">打开</button>
					<button type="button" id="downloadBtn" onclick="download()">下载到本地</button>
				</a>
			</li>

		</ul>

	</nav>
	<a aria-hidden="false" class="Hui-nav-toggle" href="#"></a> </header>
<aside class="Hui-aside">
	<input runat="server" id="divScrollValue" type="hidden" value="" />
	<div class="menu_dropdown bk_2">
		<dl id="menu-newmap">
			<dt><i class="Hui-iconfont">&#xe646;</i> 工程<i class="Hui-iconfont menu_dropdown-arrow">&#xe6d5;</i></dt>
			<dd>
				<ul>
					<li><a href="#"><label id="creatProject">新建工程</label></a></li>
					<li><a href="#"><label id="creatMap">新建图幅</label></a></li>
					<li><a href="#"><label id="fileManage">文件</label></a></li>
				</ul>
			</dd>
		</dl>
		<dl id="menu-restable">
			<dt><i class="Hui-iconfont">&#xe618; </i><label id="resTable">成果表</label><i class="Hui-iconfont menu_dropdown-arrow">&#xe6d5;</i></dt>
			<dd>
				<ul>
					<li><a href="#"><label id="liPiletable">转角直线桩表</label></a></li>
					<li><a href="#"><label id="liTowerlisttable">杆塔排位成果表</label></a></li>
				</ul>
			</dd>
		</dl>
		<dl id="menu-parameter">
			<dt><i class="Hui-iconfont">&#xe681; </i><label id="param"> 参数</label><i class="Hui-iconfont menu_dropdown-arrow">&#xe6d5;</i></dt>
			<dd>
				<ul>
					<li><a href="#"><label id="designparameter">设计参数</label></a></li>
				</ul>
				<ul>
					<li><a href="#"><label id="framepara">图框参数</label></a></li>
				</ul>
				<ul>
					<li><a href="#"><label id="drawingpara">图纸参数</label></a></li>
				</ul>
			</dd>
		</dl>
		<dl id="menu-input">
			<dt><i class="Hui-iconfont">&#xe645;</i> 输入输出<i class="Hui-iconfont menu_dropdown-arrow">&#xe6d5;</i></dt>
			<dd>
				<ul>
					<li><a href="#"><label id="inputDem">数字高程模型</label></a></li>
					<li><a href="#"><label id="inputCorner">转角杆塔投影线</label></a></li>
				</ul>
			</dd>
		</dl>
		<dl id="menu-createObject">
			<dt><i class="Hui-iconfont">&#xe645;</i> 创建<i class="Hui-iconfont menu_dropdown-arrow">&#xe6d5;</i></dt>
			<dd>
				<ul>
<!--					<li><a href="#"><label id="create_Object">创建地物</label></a></li>-->
					<li><a href="#"><label id="select_code">选择编码</label></a></li>
				</ul>
			</dd>
		</dl>
		<dl id="menu-manualrank">
			<dt><i class="Hui-iconfont">&#xe647; </i><label id="hand"> 手工排位</label><i class="Hui-iconfont menu_dropdown-arrow">&#xe6d5;</i></dt>
			<dd>
				<ul>
					<li id="putTower"><a href="#"><label>放置杆塔</label></a></li>
					<li id="deleteTower"><a href="#"><label>删除杆塔</label></a></li>
					<li id="moveTower"><a href="#"><label>移动杆塔</label></a></li>
					<li id="insertTower"><a href="#"><label>插入杆塔</label></a></li>
					<li id="riseTower"><a href="#"><label>升高杆塔</label></a></li>
					<li id="fallTower"><a href="#"><label>降低杆塔</label></a></li>
					<li id="editTower"><a href="#"><label>修改排杆</label></a></li>
					<li id="saveTower"><a href="#"><label>保存排杆</label></a></li>
				</ul>
			</dd>
		</dl>
		<dl id="menu-savemap">
			<dt><i class="Hui-iconfont">&#xe646; </i><label id="saveAs"> 保存</label><i class="Hui-iconfont menu_dropdown-arrow">&#xe6d5;</i></dt>
			<dd>
				<ul>
					<li><a href="#"><label id="saveMap">保存Map</label></a></li>
					<li><a href="#"><label id="savePrj">保存工程</label></a></li>
				</ul>
			</dd>
		</dl>
		<dl id="menu-transOutput">
			<dt><i class="Hui-iconfont">&#xe646; </i><label id="Output"> 导出</label><i class="Hui-iconfont menu_dropdown-arrow">&#xe6d5;</i></dt>
			<dd>
				<ul>
<!--					<li><a href="#"><label id="outputDXF">导出DXF</label></a></li>-->
					<li><a href="#"><label id="outputORG">导出ORG</label></a></li>
				</ul>
			</dd>
		</dl>
		<div style="display: none">
			<label>打开本地json文件: <input type="file" style="display:inline-block" id="jsonfile" name="myjsonfile" accept=".json"/>
				<input type="button" style="display:inline-block" id="openjsonfile" onclick="window.upjsonfile()" value="打开" /></label>
			<label>打开本地prj文件: <input type="file" style="display:inline-block" id="TLfile" name="myTLfile" accept="./PRJ"/>
				<input type="button" style="display:inline-block" id="openTLfile" onclick="window.upprjfile()" value="打开" /></label>
			<label>打开本地map文件: <input type="file" style="display:inline-block" id="TLmapfile" name="myTLmapfile" accept=".MAP"/>
				<input type="button" style="display:inline-block" id="openTLmapfile" onclick="window.upmapfile()" value="打开" /></label>
			<label>打开本地pwf文件: <input type="file" style="display:inline-block" id="TLpwffile" name="myTLpwffile" accept=".PWF"/>
				<input type="button" style="display:inline-block" id="openTLpwffile" onclick="window.uppwffile()" value="打开" /></label>
			<label>打开本地prk文件: <input type="file" style="display:inline-block" id="TLprkfile" name="myTLprkfile" accept=".PRK"/>
				<input type="button" style="display:inline-block" id="openTLprkfile" onclick="window.upprkfile()" value="打开" /></label>
		</div>
	</div>
</aside>

<div class ="designParam" id="piletable" style="height: 400px;">
	<div>
		<h4 style="margin-left: 2%;" id="piletable_title">转角直线表</h4>
	</div>

	<table id="mpile_table"></table>
	<div class="line" style="outline-color: #1b1b1b;line-height: 5px;">-----</div>
	<div style="display: inline;">
		<!--		<button class="input-file" id="opentxt">文件上传</button>-->

			<button class="xbutton xround"  style="margin-left:5px;">		<input type="file" id ="tb_pile_input" accept=".txt"> </button>
			<button class="xbutton xround" id="tb_pile_calc" style="text-align-last: right">计算</button>
			<button class="xbutton xround" id="tb-pile-save" style="text-align-last: right">保存</button>
			<button class="xbutton xround close_btn" id="closeTable"style="text-align-last: right">关闭</button>

	</div>
</div>
<div class ="designParam" id="towerlisttable" style="height: 400px;">
	<div>
		<h4 style="margin-left: 2%;" id="towerlisttable_title">杆塔排位成果表</h4>
	</div>
	<table id="towerlist_table"></table>
	<div style="text-align-last:right">
		<button class="xbutton xround" id="tb-towerlist-calc" style="text-align-last: right" onclick="towerlistCalc()">重算</button>
		<button class="xbutton xround close_btn" id="towerlistcloseTable"style="text-align-last: right">关闭</button>
	</div>
</div>

<div class="designParam" id="Paramtable">
	<div class = "designParamtitle">
		<h2 id="h2title">详细设计参数</h2>
	</div>
	<div class="paramBtn" style="display:inline-block">
		<p><button class="xbutton xround" id="guicheng">规程要求设置</button></p>
		<p><button class="xbutton xround" id="daodixian">导地线参数</button></p>
		<p><button class="xbutton xround" id="qixiang">气象条件</button></p>
		<p><button class="xbutton xround" id="fenduan">分段设置</button></p>
		<p><button class="xbutton xround" id="gantashiyong">杆塔使用参数</button></p>
		<p><button class="xbutton xround" id="gantatacai">杆塔塔材基础</button></p>
		<p><button class="xbutton xround" id="jueyuancan">绝缘子串参数</button></p>
		<p><button class="xbutton xround" id="jueyuancai">绝缘子串材料</button></p>
		<p><button class="xbutton xround" id="jiedican">接地装置参数</button></p>
		<p><button class="xbutton xround" id="jiedicai">接地装置材料</button></p>
		<p><button class="xbutton xround" id="fangzhenchui">防震锤 参数</button></p>
		<p><button class="xbutton xround" id="youhua">优化排位参数</button></p>
	</div>
	<div class="outlineDiv" style="display:inline-block">
		<table id='outlineTable'></table>
	</div>
	<div class="operateBtn" style="display:inline-block">
		<p><button class="xbutton xround edit">追加</button></p>
		<p><button class="xbutton xround edit">插入</button></p>
		<p><button class="xbutton xround edit">删除</button></p>
		<p><button class="xbutton xround edit">清空</button></p>
		<p><button class="xbutton xround edit">上移</button></p>
		<p><button class="xbutton xround edit">下移</button></p>
		<p><button class="xbutton xround" id="database" action="TL_BL.html">数据库</button></p>
		<p><button class="xbutton xround" id="save">保存</button></p>
		<p><button class="xbutton xround closeBtn">关闭</button></p>
	</div>
	<div class="detailsDiv" style="display:inline-block">
		<table id='detailsTable'></table>
	</div>
</div>
<div class="dislpayArrow"><a class="pngfix" href="javascript:void(0);" onClick="displaynavbar(this)"></a></div>
<section class="Hui-article-box">
	<div id="Hui-tabNav" class="Hui-tabNav">
		<div class="Hui-tabNav-wp">
			<ul id="min_title_list" class="acrossTab cl">
				<li class="active"><span title="工作区" id="span_id"> 工作区</span><em></em></li>
			</ul>
		</div>
		<div class="Hui-tabNav-more btn-group"><a id="js-tabNav-prev" class="btn radius btn-default size-S" href="javascript:;"><i class="Hui-iconfont">&#xe6d4;</i></a><a id="js-tabNav-next" class="btn radius btn-default size-S" href="javascript:;"><i class="Hui-iconfont">&#xe6d7;</i></a></div>
	</div>
	<div id="iframe_box" class="Hui-article">
	</div>
	<footer id="footermsg" class="footer mt-20" style="z-index: 100;position: fixed;bottom: 0;height: 50px">
		<div class="container-fluid">

		</div>
	</footer>
</section>


<!--<script type=“module” src="./js/DragControls.js"></script>-->

<script type="module">
	import { CSS2DRenderer, CSS2DObject } from './js/CSS2DRenderer.js';

	//系统设置
	var prjName;//新建工程名
	var MapFileName;
	var prjNameJSON = {};
	let prk = {};//prk
	let lao = {};
	var data = [];
	var towerHei = 45;//塔高
	var towerHeiDif = 0;//最高塔高-最低塔高
	var towerHeiInDif = 0;//塔高间隔
	var towerHeiArray = [];//塔高数组
	var towerStartHei = 0;
	var towerEndHei = 0;
	var towerlist = [];//塔组
	var m_start,m_end;  //4.8
	var wirelist = [];//导线组
	var savedJson = {"DEM":"","GEO":"","pwf":"","prk":"","Lao":""};//保存json

	/**           部分设计参数          **/
	var voltageArr = ['110kV','220kV','330kV','500kV','直流500kV','750kV','直流800','1000kV'];
	var circuitArr = ['单回路','双回路'];
	var conductorArr = ['导线','地线','OPGW'];
	var towerArr = ['直线塔','耐张塔','终端塔','龙门架'];
	var toweraddTypeArr = ['自立塔','拉线塔'];
	var insulateArr = ['导线悬垂串','导线耐张串','导线跳线串','地线悬垂串','地线耐张串'];
	var sindouArr = ['单联','双联'];
	var dirtyareaArr = ['I级污秽区'];
	var insulateMateArr = ['','','','瓷质绝缘子'];
	var columndataLeft = [{key: 'id', text: 'NO'}, {key: 'name', text: '型号/名称/图号'}];//表头
	var columndataRight = [{key: 'name', text: '参数名称'}, {key: 'value', text: '参数数值'}];//表头

	let tpIndex;

	let mp={};
	let blankmp = {};
	let cross=[];

	let TowerScriptGroup = new THREE.Group();
	TowerScriptGroup.name = "TowerScriptLabel";
	let TowerGroup = new THREE.Group();
	TowerGroup.name = "fixTowerGroup";
	let FawCurveGroup = new THREE.Group();
	FawCurveGroup.name = "fixCurveGroup";
	let ttowerlist = Array;
	let movingInd;

	//pilelist table init
	{
	var pile_tabledata=[];
	var pile_tableId=document.getElementById("mpile_table");
	console.log(pile_tableId);
	var tb_pile=new GridManager(pile_tableId,{
		gridManagerName: 'TL-piletable',
				ajaxData: {"data":pile_tabledata},
				ajaxType: 'POST',
				//supportMenu: true,// 默认为true
							menuHandler: list => {
								list.unshift({
									content: '交换X Y',
									//line: true,
									onClick: function(){
										for(let i=0;i<pile_tabledata.length;i++)
										{
											var temp;
											temp=pile_tabledata[i].x;
											pile_tabledata[i].x=pile_tabledata[i].y;
											pile_tabledata[i].y=temp;
										}

										GridManager.refreshGrid(pile_tableId);
										console.log("exchanged data x y ");
										console.log(pile_tabledata);
									}

								});
								// list.unshift({
								// 	content:'test right click button',
								// 	//line:true,
								// 	onClick:function (){alert("test finish")}
								// });
								return list;
							},
			columnData: [
				{
					key: 'name',
					text: '杆位名称'
				},{
					key: 'dist',
					text: '累距'
				},{
					key: 'z',
					text: '高程'
				},{
					key: 'secdist',
					text: '距离'
				},{
					key: 'x',
					text: '大地x坐标'
				},{
					key: 'y',
					text: '大地y坐标'
				}
				,{
					key: 'angle',
					text: '转角'
				}
				,{
					key: 'my',
					text: '点位误差'
				}
				,{
					key: 'error',
					text: '航测断面较差'
				}
			],

		},
			function(){}
	);
	console.log(GridManager.get(pile_tableId));
	}
// towerlist table init
	{
		var towerlist_tabledata=[];
		console.log("towerlist begin data");
		console.log(towerlist_tabledata);
		console.log("tihuan data");
		towerlist_tabledata=towerlist;  //table data format different with towerlist_tabledata parameters default
		console.log(towerlist_tabledata);
		var towerlist_tableId=document.getElementById("towerlist_table");
		console.log(pile_tableId);
		var tb_towerlist=new GridManager(towerlist_tableId,{
					gridManagerName: 'TL-towerlisttable',
					ajaxData: {"data":towerlist_tabledata},
					ajaxType: 'POST',
					menuHandler: list => {
						list.unshift({
							content: '重排塔杆编号',
							//line: true,
							onClick: function(){
								var head =prompt("首字母","G");
								var fid=prompt("起始编号","0");
								for(let i=0;i<towerlist_tabledata.length;i++)
								{
									console.log(fid-"0"+i);
									towerlist_tabledata[i].Name=head.toString()+(fid-"0"+i).toString();
								}
								towerlistCalc();
								GridManager.setAjaxData(towerlist_tableId,{"data":towerlist_tabledata});
								GridManager.refreshGrid(towerlist_tableId);
								console.log("reset name");
								console.log(towerlist_tabledata);
							}

						});
						list.unshift({
							content:'删除所选塔杆',
							//line:true,
							onClick:function (){
								console.log("right button checklist");

								var del_tower=GridManager.getCheckedData(towerlist_tableId); //checkedtower need to delete former list
								console.log(del_tower);
								for(let i=0;i<del_tower.length;i++){
									for(let j=0;j<towerlist_tabledata.length;j++){
										if(del_tower[i].Name==towerlist_tabledata[j].Name){
											towerlist_tabledata.splice(j,1);
										}
									}
								}
								console.log("tabledelete",towerlist);
								console.log(towerlist_tabledata);
								TowerGroup.children.length = 0;
								TowerScriptGroup.children.length = 0;
								FawCurveGroup.children.length = 0 ;
								TowerDraw(towerlist_tabledata);
								towerlist = towerlist_tabledata;
								console.log(towerlist);

								console.log("tabledata changed");
								console.log(towerlist_tabledata);
								for(let i=0;i<towerlist_tabledata.length;i++){
									if(towerlist_tabledata[i].offset>0)towerlist_tabledata[i].PosOffset = towerlist_tabledata[i].Position+"+"+towerlist_tabledata[i].offset.toString();
									else towerlist_tabledata[i].PosOffset = towerlist_tabledata[i].Position+towerlist_tabledata[i].offset.toString();
								}
								GridManager.setAjaxData(towerlist_tableId,{"data":towerlist_tabledata});
								GridManager.refreshGrid(towerlist_tableId);
								del_tower=GridManager.setCheckedData(towerlist_tableId,[]);
							}
						});
						list.unshift({
							content:'重算杆塔位置',
							//line:true,
							onClick:function (){alert("recalc towerlist finish")} //什么情况下会重算杆塔位置
						});
						return list;
					},
					columnData: [
						{
							key: 'Name',
							text: '杆号'
						},{
							key: 'Distance',
							text: '累距'
						},{
							key: 'High',
							text: '桩位高程'
						},{
							key: 'l2',
							text: '前侧档距'
						},{
							key: 'PosOffset',
							text: '杆塔位置',
						},{
							key: 'TowerType',
							text: '杆型'
						}
						,{
							key: 'TowerHigh',
							text: '塔高'
						}
						,{
							key: 'Base',
							text: '降基'
						}
						,{
							key: 'Angle',
							text: '转角数'
						}
						,{
							key: 'Lh',
							text: '水平档距'
						}
						,{
							key: 'Lv',
							text: '垂直档距'
						}
						,{
							key: 'InsulatorLength',
							text: '导线串长'
						}
						,{
							key: 'LandDist',
							text: '前侧对地距离'
						}
						,{
							key: 'ElecDist',
							text: '前侧跨越距离'
						}
						,{
							key: 'Lk',
							text: '前侧代表档距'
						}
						,{
							key: 'kPline',  //kPline/1.0*1E5
							text: '前侧模板k值'
						}
						,{
							key: 'u',
							text: '前侧放松系数'
						}

					],
				},
				function(){}
		);
	}

	//pile table
	//$("#piletable").draggable();
	//window resize;
	$("#piletable").hide();
	$("#liPiletable").click(function () {
		$("#piletable").show();
	})
	$("#closeTable").click(function () {
		$("#piletable").hide();
	})

	//towerlisttable
	console.log(towerlist);
	//$("#towerlisttable").draggable();
	//window resize;
	$("#towerlisttable").hide();
	$("#liTowerlisttable").click(function () {
		$("#towerlisttable").show();

		//towerlist_tabledata=towerlist;
		towerlistCalc();
		GridManager.refreshGrid(towerlist_tableId);

	})
	$("#towerlistcloseTable").click(function () {
		$("#towerlisttable").hide();
	})

	window.TowerDraw = function(towerlist_tabledata){
		var conductset;

		console.log(m_start,m_end)
		m_end = towerlist_tabledata.length - 1;

		for (let i = 0; i <  towerlist_tabledata.length; i++) {
			console.log("Status",towerlist_tabledata[i].Status);
			let tpos={};let towerset;
			tpos.x = (towerlist_tabledata[i].Distance-xMin)/xdivision*Gridsize;
			tpos.y = (towerlist_tabledata[i].High - yMin)/ydivision*Gridsize;
			tpos.z = 0;
			towerset = createTower(tpos,towerlist_tabledata[i].Name,
					towerlist_tabledata[i].TowerType,
					towerlist_tabledata[i].Status,
					towerlist_tabledata[i].TowerHigh,
					-1);
			TowerGroup.add(towerset);
			scene.add(TowerGroup);
			var tlabel = createSpritelabel(towerlist_tabledata[i].Name,
					"Lh:"+towerlist_tabledata[i].Lh.toFixed(0)+"/Lv:"+towerlist_tabledata[i].Lv.toFixed(0)+
					"/Kv:"+(towerlist_tabledata[i].Lv.toFixed(0)/towerlist_tabledata[i].Lh.toFixed(0)).toFixed(2),
					towerlist_tabledata[i].TowerType+"-"+towerlist_tabledata[i].TowerHigh,
					"#000000",150,0,tpos.x,tpos.y+towerlist_tabledata[i].TowerHigh/ydivision*Gridsize+5,0);
			TowerScriptGroup.add(tlabel);
			scene.add(TowerScriptGroup);
		}

		if(m_end > 0){
			for (let i = m_start; i < m_end; i++) {
				conductset=DisplayFawCurve4(towerlist_tabledata[i],towerlist_tabledata[i+1], "fixwire");
				FawCurveGroup.add(conductset[0]);
				FawCurveGroup.add(conductset[1]);
				FawCurveGroup.add(conductset[2]);
			}
		}
		console.log("update scene TowerDraw");
		scene.add(FawCurveGroup);
		console.log(scene);
	}

	//prk设计参数框显示/隐藏
	//$("#Paramtable").draggable({handle:"#h2title"});
	$("#Paramtable").hide();
	$("#database").click(function(){
		layer.open({
			type:2,
			title:'读数据库',
			resize :true,
			//area:['500px','650px'],
			content:'./tbTest.html',
			success:function (layero,index) {

			}
		})
	})
	$("#designparameter").click(function () {
		$("#Paramtable").show();
	})
    //prk database

	$(".closeBtn").click(function () {
		$("#Paramtable").hide();
	})
	var fileObj=[];
	$("#tb_pile_input").change(function(){
		var pile_table=[];
		fileObj = this.files[0]; // js 获取文件对象
		console.log(fileObj);
		var form = new FormData(); // FormData 对象
		form.append("file", fileObj); // 文件对象
		form.append("ProjectName", prjName);//控制路径
		console.log("ProjectName",prjName);
		$.ajax({
			url: BASEURL+"/txtToJson", //提交的路径
			type: "post",       //提交方式
			data: form,    //提交的数据
			contentType: false, // 告诉jQuery不要去设置Content-Type请求头
			processData: false,
			success: function (res) {
				console.log(res);
				pile_tabledata =res;
				GridManager.setAjaxData(pile_tableId,{"data":pile_tabledata});
			}
		});

	})

	$("#tb_pile_calc").click(function(){
		var form = new FormData();
		form.append("ProjectName", prjName);
		console.log("begindata");
		console.log(pile_tabledata);
		form.append("table",JSON.stringify(pile_tabledata));
		//console.log(pile_table.m_jPile);   //txt append jsondata
		$.ajax({
				url: BASEURL+"/tbCalc", //提交的路径
				type: "post",       //提交方式
				data: form,    //提交的数据
				// dataType:"json",
				contentType: false, // 告诉jQuery不要去设置Content-Type请求头
				processData: false,
				success: function (res) {
					console.log("caculate cacu res");
					console.log(res.m_jPile);
					pile_tabledata=res.m_jPile;
					//console.log(GridManager.getAjaxData(pile_tableId));
					//need to caculate the secdist
					for(let i=0;i<pile_tabledata.length;i++)
					{
						var temp;
						temp=pile_tabledata[i].x;
						pile_tabledata[i].x=pile_tabledata[i].y;
						pile_tabledata[i].y=temp;
					}   //系统坐标大地坐标相反对换

					if(pile_tabledata.length>0){pile_tabledata[0].secdist=0;}
					for(let i=1;i<pile_tabledata.length;i++){
						pile_tabledata[i].secdist=pile_tabledata[i].dist-pile_tabledata[i-1].dist;
					}
					GridManager.setAjaxData(pile_tableId,{"data":pile_tabledata});
				}
})})

	$("#tb-pile-save").click(function (){
		var form = new FormData();
		console.log(pile_tabledata);
		form.append("table",JSON.stringify(pile_tabledata));
		form.append("ProjectName", prjName);
		$.ajax({
			url: BASEURL+"/JsonTotxtfile", //提交的路径
			type: "post",       //提交方式
			data: form,    //提交的数据
			// dataType:"json",
			contentType: false, // 告诉jQuery不要去设置Content-Type请求头
			processData: false,
			success: function (res) {
				console.log(res);
			}
		})
	})

	window.towerlistCalc = function(){
		var form = new FormData();
		form.append("ProjectName",prjName);
		console.log("begindata");
		console.log("towerlistTabledata",towerlist_tabledata);
		console.log("towerlist",towerlist);

		//position and offset setting "J0"+"±123"
		for(let j=0;j<towerlist_tabledata.length;j++){
			let disToPile = []
			for (let i = 0; i < pile_tabledata.length; i++) {
				disToPile.push({
					"name": pile_tabledata[i].name,
					"dis": Math.abs(pile_tabledata[i].dist - towerlist_tabledata[j].Distance),
					"value": i
				})
			}
			function compare(property){
				return function(a,b){
					var value1 = a[property];
					var value2 = b[property];
					return value1 - value2;
				}
			}
			disToPile.sort(compare("dis"));
			for (let i = 0; i < pile_tabledata.length; i++) {
				if (pile_tabledata[i].name == disToPile[0].name) {
					towerlist_tabledata[j].Position = pile_tabledata[i].name
					towerlist_tabledata[j].offset = Number((towerlist_tabledata[j].Distance- pile_tabledata[i].dist).toFixed(0));
					break;
				}
			}
		}

		form.append("table",JSON.stringify(towerlist_tabledata));
		//console.log(pile_table.m_jPile);   //txt append jsondata

		$.ajax({
			url: BASEURL+"/tbtowerlistCalc", //提交的路径
			type: "post",       //提交方式
			data: form,    //提交的数据
			//dataType:"json",
			contentType: false, // 告诉jQuery不要去设置Content-Type请求头
			processData: false,
			success: function (res) {
				console.log("calc pwf finsh");
				console.log(res);
				towerlist_tabledata = res.TOWERLIST;
				console.log("res.TOWERLIST",res.TOWERLIST);
				for(let i=0;i<res.TOWERLIST.length;i++){
					if(res.TOWERLIST[i].offset>0)res.TOWERLIST[i].PosOffset = res.TOWERLIST[i].Position+"+"+res.TOWERLIST[i].offset.toString();
					else res.TOWERLIST[i].PosOffset = res.TOWERLIST[i].Position+res.TOWERLIST[i].offset.toString();
				}
				GridManager.setAjaxData(towerlist_tableId,{"data":res.TOWERLIST});

			}
		})
	}


	$("#outputORG").click(function(){
		var form = new FormData();
		form.append("ProjectName",prjName);
		form.append("MapFile",(MapFileName+".MAP").toString());
		form.append("PwfFile",(prjName+".PWF").toString());
		$.ajax({
			url: BASEURL+"/MapOutput", //提交的路径
			type: "post",       //提交方式
			data: form,    //提交的数据
			//dataType:"json",
			contentType: false,
			processData: false,
			success: function () {
				//download file
				download(prjName,MapFileName+".ORG");
			}
		})
	})

	$("#drawingpara").click(function(){

		let drawintial = [];
		drawintial.push(mp.m_Volumns);	drawintial.push(mp.m_MapWidth);	drawintial.push(mp.m_suffixlength);
		drawintial.push(mp.m_From);	drawintial.push(mp.m_To);	drawintial.push(mp.m_To-mp.m_From);
		drawintial.push(mp.m_Grid);	drawintial.push(mp.m_pGrid);	drawintial.push(mp.m_hGrid);
		drawintial.push(mp.m_ShowMainGrid);	drawintial.push(mp.m_ShowSubGrid);	drawintial.push(mp.m_dynamicPlan);
		drawintial.push(mp.m_showNoTower);	drawintial.push(mp.m_ShowTower);	drawintial.push(mp.m_ShowCrossLine);
		drawintial.push(mp.m_ShowSafeLine);	drawintial.push(mp.m_ShowZPile);	drawintial.push(mp.m_ShowJPile);
		drawintial.push(mp.m_ShowGPile);
		drawintial.push(mp.m_DScale);	drawintial.push(mp.m_HScale);drawintial.push(mp.m_CScale);
		drawintial.push(mp.m_StandardFrame);	drawintial.push(mp.m_CircleFrame);drawintial.push(mp.m_SignFrame);
		drawintial.push(mp.m_showAllPoint);	drawintial.push(mp.m_ShowSurveyPoint);drawintial.push(mp.m_ShowPointName);drawintial.push(mp.m_ShowPointY);
		drawintial.push(mp.m_sideWidth);	drawintial.push(mp.m_HighSystem);

		layer.open({
			type:2,
			title:'图纸参数',
			area:['700px','360px'],
			maxmin:true,
			//shadeClose:true,
			content:'./html/drawingpara.html',
			success:function (layero,index) {
				var body = layer.getChildFrame('body',index);
				let i=0;
				body.find('input').each(function () {
					if($(this).attr("type")=="checkbox"){
							if(drawintial[i]==1){
								console.log(drawintial[i]);
								$(this).prop("checked","true");
							}
							//else $(this).prop("checked","false");
					}
					else $(this).val(drawintial[i]);
					i++;
				})
			}
		})
	})

	window.updatedrawing=function(draw_list) {
		mp.m_Volumns=draw_list[0];	mp.m_MapWidth=Number(draw_list[1]);	mp.m_suffixlength=Number(draw_list[2]);
		mp.m_From=Number(draw_list[3]);	mp.m_To=Number(draw_list[4]);	//mp.m_To-mp.m_From=draw_list[5];
		mp.m_Grid=Number(draw_list[6]);	mp.m_pGrid=Number(draw_list[7]);	mp.m_hGrid=Number(draw_list[8]);
		mp.m_ShowMainGrid=draw_list[9];	mp.m_ShowSubGrid=draw_list[10];	mp.m_dynamicPlan=draw_list[11];
		mp.m_showNoTower=draw_list[12];	mp.m_ShowTower=draw_list[13];	mp.m_ShowCrossLine=draw_list[14];
		mp.m_ShowSafeLine=draw_list[15];	mp.m_ShowZPile=draw_list[16];	mp.m_ShowJPile=draw_list[17];
		mp.m_ShowGPile=draw_list[18];
		mp.m_DScale=Number(draw_list[19]);	mp.m_HScale=Number(draw_list[20]);mp.m_CScale=Number(draw_list[21]);
		mp.m_StandardFrame=draw_list[22];	mp.m_CircleFrame=draw_list[23];mp.m_SignFrame=draw_list[24];
		mp.m_showAllPoint=draw_list[25];	mp.m_ShowSurveyPoint=draw_list[26];mp.m_ShowPointName=draw_list[27];mp.m_ShowPointY=draw_list[28];
		mp.m_sideWidth=Number(draw_list[29]);	mp.m_HighSystem=draw_list[30];
		console.log(mp);
		console.log(scene.children);
		ydivision=mp.m_HScale*mp.m_Grid/mp.m_CScale; xdivision = mp.m_DScale*mp.m_Grid/mp.m_CScale;Gridsize =mp.m_Grid;
		horSize=(mp.m_To-mp.m_From)*mp.m_CScale/(mp.m_Grid*mp.m_DScale)*Gridsize;  verSize = (mp.m_MapWidth-mp.m_Frame[14])*mp.m_HScale/(1000*ydivision)*Gridsize;
		xMin = mp.m_From;
		console.log(horSize,verSize,xdivision,ydivision,mp.m_Grid,Gridsize,mp.m_CScale, mp.m_From,"update drawing");
		drawDEM(DEM);
		MapCrossDraw(cross,false);  //cross added
		TowerDraw(towerlist_tabledata);
		drawGeo(pile_tabledata);
		window.initContent();
		console.log(scene.children);
	}

	$("#framepara").click(function(){
		layer.open({
			type:2,
			title:'图框参数',
			area:['500px','650px'],
			maxmin:true,
			content:'./html/framepara.html',
			success:function (layero,index) {
				console.log(layero,index);
				var body = layer.getChildFrame('body',index);
				console.log(body);
				var inputList = body.find('input');
				for (var j = 0; j < inputList.length-1; j++) {			//把父页面的数据放到子页面的input框中
					body.find(inputList[j]).val(mp.m_Frame[14-j]-mp.m_Frame[14-j-1]);
				}
				body.find(inputList[14]).val(mp.m_Frame[0]);
				body.find(inputList[15]).val(mp.m_prefixLength);
			}
		})
	})

	window.updatemp=function(mppara) {
		mp.m_prefixLength = Number(mppara.m_prefixLength);
		mp.m_Frame = mppara.m_Frame;
		MapCrossDraw(cross,false);
	}

	$("#select_code").click(function(){

		layer.open({
			type:2,
			title:'选择地物类别',
			area:['250px','400px'],
			maxmin:true,
			content:'./html/selectCode.html',
			shade:0,
			success:function (layero,index) {
				console.log(layero,index);
				var body = layer.getChildFrame('body',index);
				console.log(body);
		},

			resizing:function(layero){
				console.log(layero);
			},
			cancel: function(index, layero){

					document.removeEventListener('mousedown', window.createGroundObj);
					document.removeEventListener('mousemove', window.trackGroundObj);
					layer.close(index)

				return false;
			}
		})

	})

	// DEM断面提取layer
	var secDEM=[];
	console.log(secDEM);
	$("#inputDem").click(function (){
		//转角文件exist
		//if(parent.document.getElementById('tb_pile_input').files[0]==null||pile_tabledata.length==0){alert("选择转角文件");}
			layer.open({
				type: 2,
				title: 'DEM断面提取',
				area: ['300px', '300px'],
				maxmin: true,
				content: './html/SectionMap.html',
				success: function (layero, index) {
					console.log(layero, index);
					var body = layer.getChildFrame('body', index);
					var inputList = body.find('input');     //取得子页面中input输入框
					var dataLists = [15, 5];
					for (var j = 0; j < inputList.length; j++) {			//把父页面的数据放到子页面的input框中
						body.find(inputList[j]).val(dataLists[j]);
					}




					var optionList = body.find('select');
					console.log(optionList);
					console.log(pile_tabledata);
					for (let i = 0; i < pile_tabledata.length; i++) {
						var newOption0 = new Option(pile_tabledata[i].name, i.toString());
						var newOption1 = new Option(pile_tabledata[i].name, i.toString());
						optionList[1].options.add(newOption0);
						optionList[2].options.add(newOption1);
					}
					$.ajax({
						url: BASEURL+"/directory/" + prjName, //提交的路径
						type: "get",       //提交方式
						dataType:"json",
						success: function(data){
							console.log(data);
							for (let i = 0; i < data.length; i++) {
								var filename = data[i].name;
								var suffix = filename.substring(filename.lastIndexOf('.')+1);
								if(suffix=="EGX"||suffix=="tif"||suffix=="asc"){
									var fileOption = new Option(data[i].name, i.toString());
									console.log(fileOption);
									optionList[0].options.add(fileOption);
								}
							}
						}
					})

					console.log("SectionMapOption",optionList[0]);

				},
				yes: function (index, layero) {
					console.log("yes function feedback" + layero + "" + index);

				}

			})


	})

	window.GetSecDem= function(transobj){
		var formData = new FormData();
		formData.append("SectionInfo",JSON.stringify(transobj)); //transobj get from sonPage SectionMap.html
		formData.append("ProjectName", prjName);
		$.ajax({
			url: BASEURL+"/SectionMapSave", //提交的路径
			type: "post",       //提交方式
			data: formData,    //提交的数据
			dataType:"json",
			async: false,
			cache: false,
			contentType: false, // 告诉jQuery不要去设置Content-Type请求头
			processData: false,
			success: function (data) {
				console.log("SectionMapSave",data);
				DEM= data.DEM;
				mp = data.mp;
				cross = data.cross;
			},
			error: function (errorMsg) {
			//	alert(errorMsg);
			}
		});
		console.log("DEM,mp,cross updata",DEM,mp,cross);
		//$("#drawingpara").click();
		ydivision=mp.m_HScale*mp.m_Grid/mp.m_CScale; xdivision = mp.m_DScale*mp.m_Grid/mp.m_CScale;Gridsize =mp.m_Grid;
		horSize=(mp.m_To-mp.m_From)*mp.m_CScale/(mp.m_Grid*mp.m_DScale)*Gridsize;  verSize = (mp.m_MapWidth-mp.m_Frame[14])*mp.m_HScale/(1000*ydivision)*Gridsize;
		xMin = mp.m_From;
		drawDEM(DEM);
		MapCrossDraw(cross,false);  //cross added
		TowerDraw(towerlist_tabledata);
		window.initContent();
		drawGeo(pile_tabledata);
	}

	window.download = function(ProjectName,FileName) {
		console.log("download Name",ProjectName,FileName);
		var url = BASEURL+'/Pathdownload/Project='+ProjectName+'&filename=' + FileName;
		var xhr = new XMLHttpRequest();
		xhr.open('GET', url, true);        // 也可以使用POST方式，根据接口
		xhr.responseType = "blob";    // 返回类型blob
		// 定义请求完成的处理函数，请求前也可以增加加载框/禁用下载按钮逻辑
		xhr.onload = function () {
			// 请求完成
			if (this.status === 200) {
				// 返回200
				var blob = this.response;
				var reader = new FileReader();
				reader.readAsDataURL(blob);
				reader.onload = function (e) {
					// 转换完成，创建一个a标签用于下载
					console.log(e.target);
					var a = document.createElement('a');
					a.download = FileName;
					a.href = e.target.result;
					$("body").append(a);    // 修复firefox中无法触发click
					a.click();
					$(a).remove();
				}
			}
		};
		// 发送ajax请求
		xhr.send()
	}
	//新建工程
	{
	/* 新建工程 */
	$('#creatProject').click(function(){
		// for (let i = 0; i < allChildren.length; i++){
		// 	group.remove(allChildren[i]);
		// }
		// for (let i = 0; i < scene.children.length; i++){
		// 	if (scene.children[i].name === "dem"||scene.children[i].name === "corner"){
		// 		dem.push(scene.children[i]);
		// 	}
		// 	if (scene.children[i].name === "fixTower"||scene.children[i].name === "wire"){
		// 		towerList.push(scene.children[i]);
		// 	}
		// }
		// for (let i = 0; i < dem.length; i++) {
		// 	scene.remove(dem[i]);
		// }
		// for (let i = 0; i < towerList.length; i++) {
		// 	scene.remove(towerList[i]);
		// }

		//初始化数据参数
		//xxxx
		prjName = prompt("请输入新建工程名称","");
		if(prjName){
			document.getElementById('span_id').innerHTML = prjName;
			prjNameJSON = {"ProjectName":prjName};

			$.ajax({
				url: BASEURL+"/CreateProject", //提交的路径
				type: "post",       //提交方式
				data: prjNameJSON,    //提交的数据
				dataType:"json",
				//填充prk设计参数表格
				success: function (data) {
					console.log("createproject",data);

					let json = data.prk;
					lao = data.Lao;
					savedJson.Lao = lao;
					blankmp = data.Map.mp;
					mp = data.Map.mp;
					prk = data.prk;
				},
				error: function (errorMsg) {
					//alert(errorMsg);
				}
			});
		}
	})

	$('#guicheng').click(function () {
			$('.edit').attr('disabled',true);
			$('#database').attr('disabled',true);
			$('#h2title').html($('#guicheng').html());
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":[{id:1, name: '系统设置'}, {id: 2, name: '交叉跨越'}]},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					if(checkedList[0].id === 1){
						data = [];
						console.log(prk.PRIMARY);
						data = [
							{
								'name': '电压等级',
								'value':voltageArr[prk.PRIMARY.voltage]
							},
							{
								'name':'设计回路',
								'value':circuitArr[prk.PRIMARY.circuit - 1]
							},
							{
								'name':'导线平均高度m',
								'value':prk.PRIMARY.windH
							},
							{
								'name':'地面粗糙度系数a',
								'value':prk.PRIMARY.alfa
							},
							{
								'name':'地线覆盖较冰导线增加mm',
								'value':prk.PRIMARY.dIce
							},
							{
								'name':'导线过牵引长度m',
								'value':prk.PRIMARY.pLTract
							},
							{
								'name':'孤立档最大档距m',
								'value':prk.PRIMARY.InsularMaxL
							}
						]
						document.querySelector('#detailsTable').GM({
							gridManagerName: 'details',
							supportAutoOrder: false,
							supportDrag: false,
							supportCheckbox: false,
							ajaxData: {"data":data},
							columnData: columndataRight
						});
					}
					else if (checkedList[0].id === 2){
						$('#database').attr('disabled',false);
						data = [];
						console.log(prk.PRIMARY.m_standard);
						for (let i = 0; i < prk.PRIMARY.m_standard.length; i++) {
							data.push({'name':prk.PRIMARY.m_standard[i].info,'value':prk.PRIMARY.m_standard[i].dist})
						}
						document.querySelector('#detailsTable').GM({
							gridManagerName: 'details',
							supportAutoOrder: false,
							supportDrag: false,
							supportCheckbox: false,
							ajaxData: {"data":data},
							columnData: columndataRight
						});
					}
				}
			});
		})
	$('#daodixian').click(function () {
			$('.edit').attr('disabled',false);
			$('#database').attr('disabled',false);
			$('#h2title').html($('#daodixian').html());
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":[{id:1, name: ''}]},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					if(checkedList[0].id === 1){
						data = [];
						console.log(prk.CONDUCTOR[0]);
						data = [
							{
								'name': '导地线类型',
								'value':conductorArr[prk.CONDUCTOR[0].type]
							},
							{
								'name':'导地线截面积(mm^2)',
								'value':prk.CONDUCTOR[0].A
							},
							{
								'name':'导地线直径(mm)',
								'value':prk.CONDUCTOR[0].d
							},
							{
								'name':'计算拉断力(N)',
								'value':prk.CONDUCTOR[0].Tp
							},
							{
								'name':'单位长度质量(kg/mm)',
								'value':prk.CONDUCTOR[0].p1
							},
							{
								'name':'弹性系数(N/mm^2)',
								'value':prk.CONDUCTOR[0].E
							},
							{
								'name':'膨胀系数x1E-6/℃',
								'value':prk.CONDUCTOR[0].a
							},
							{
								'name':'导线分裂数',
								'value':prk.CONDUCTOR[0].num
							}
						]
						document.querySelector('#detailsTable').GM({
							gridManagerName: 'details',
							supportAutoOrder: false,
							supportDrag: false,
							supportCheckbox: false,
							ajaxData: {"data":data},
							columnData: columndataRight
						});
					}
				}
			});
		})
	$('#qixiang').click(function () {
			$('.edit').attr('disabled',false);
			$('#database').attr('disabled',false);
			$('#h2title').html($('#qixiang').html());
			data = [];
			for (let i = 0; i < prk.WEATHER.length; i++) {
				data.push({
					'id':i+1,
					'name':prk.WEATHER[i].name
				})
			}
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":data},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					if (checkedList[0].id === 1) {
						data = [];
						for (let j = 0; j < prk.WEATHER[0].TWI.length; j++) {
							data.push({
								'name': prk.WEATHER[0].TWI[j].name,
								't': prk.WEATHER[0].TWI[j].t,
								'v': prk.WEATHER[0].TWI[j].v,
								'b': prk.WEATHER[0].TWI[j].b
							})
						}
						document.querySelector('#detailsTable').GM({
							gridManagerName: 'details',
							supportAutoOrder: false,
							supportDrag: false,
							supportCheckbox: false,
							ajaxData: {"data": data},
							columnData: [{key: 'name', text: '气象条件'}, {key: 't', text: '温度℃'}, {
								key: 'v',
								text: '风速m/s'
							}, {key: 'b', text: '覆冰(导)mm'}]
						});
					}
					else if (checkedList[0].id === 2) {
						data = [];
						for (let j = 0; j < prk.WEATHER[1].TWI.length; j++) {
							data.push({
								'name':prk.WEATHER[1].TWI[j].name,
								't':prk.WEATHER[1].TWI[j].t,
								'v':prk.WEATHER[1].TWI[j].v,
								'b':prk.WEATHER[1].TWI[j].b
							})
						}
						document.querySelector('#detailsTable').GM({
							gridManagerName: 'details',
							supportAutoOrder: false,
							supportDrag: false,
							supportCheckbox: false,
							ajaxData: {"data":data},
							columnData: [{key: 'name', text: '气象条件'}, {key: 't', text: '温度℃'},{key: 'v', text: '风速m/s'}, {key: 'b', text: '覆冰(导)mm'}]
						});
					}
				}
			});
		})
	$('#fenduan').click(function () {
			$('.edit').attr('disabled',false);
			$('#database').attr('disabled',true);
			$('#h2title').html($('#fenduan').html());
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":[{id:1, name: prk.SECTION[0].name}]},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					if(checkedList[0].id === 1){
						data = [];
						console.log(prk.SECTION[0]);
						data = [
							{
								'name': '起始桩号',
								'value':prk.SECTION[0].starJ
							},
							{
								'name':'起始累距',
								'value':prk.SECTION[0].from
							},
							{
								'name':'终点桩号',
								'value':prk.SECTION[0].endJ
							},
							{
								'name':'终点累距',
								'value':prk.SECTION[0].to
							},
							{
								'name':'气象区名称',
								'value':prk.SECTION[0].wertherName
							},
							{
								'name':'导线型号',
								'value':prk.SECTION[0].powerLine
							},
							{
								'name':'导线新线系数',
								'value':prk.SECTION[0].pLineK
							},
							{
								'name':'导线安全系数',
								'value':prk.SECTION[0].pLineF
							},
							{
								'name':'导线年平运行张力上限',
								'value':prk.SECTION[0].pLineC
							},
							{
								'name':'地线型号',
								'value':prk.SECTION[0].groundLine
							},
							{
								'name':'地线新线系数',
								'value':prk.SECTION[0].gLineK
							},
							{
								'name':'地线安全系数',
								'value':prk.SECTION[0].gLineF
							},
							{
								'name':'地线年平运行张力上限',
								'value':prk.SECTION[0].gLineC
							},
							{
								'name':'设计回路',
								'value':circuitArr[prk.SECTION[0].circuit - 1]
							}
						]
						document.querySelector('#detailsTable').GM({
							gridManagerName: 'details',
							supportAutoOrder: false,
							supportDrag: false,
							supportCheckbox: false,
							ajaxData: {"data":data},
							columnData: columndataRight
						});
					}
				}
			});
		})
	$('#gantashiyong').click(function () {
			$('.edit').attr('disabled',false);
			$('#database').attr('disabled',false);
			$('#h2title').html($('#gantashiyong').html());
			data = [];
			for (let i = 0; i < prk.TOWER.length; i++) {
				data.push({
					'id':i+1,
					'name':prk.TOWER[i].Name,
					'NO':prk.TOWER[i].No
				})
			}
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":data},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					for (let j = 0; j < prk.TOWER.length; j++) {
						if ( j === checkedList[0].NO){
							data = [];
							data = [
								{
									'name': '杆塔类型',
									'value': towerArr[prk.TOWER[j].type]
								},
								{
									'name': '最大档距(m)',
									'value': prk.TOWER[j].MaxL
								},
								{
									'name': '水平档距(m)',
									'value': prk.TOWER[j].LH
								},
								{
									'name': '垂直档距(m)',
									'value': prk.TOWER[j].LV
								},
								{
									'name': '起始呼高(m)',
									'value': prk.TOWER[j].StartHigh
								},
								{
									'name':'级差增量(m)',
									'value':prk.TOWER[j].Dhigh
								},
								{
									'name': '终止呼高(m)',
									'value': prk.TOWER[j].EndHigh
								},
								{
									'name': '最小转角度数(°)',
									'value': prk.TOWER[j].MinAngle
								},
								{
									'name': '最大转角度数(°)',
									'value': prk.TOWER[j].MaxAngle
								},
								{
									'name': '角度折算水平档距(m/°)',
									'value': prk.TOWER[j].Angle2LH
								},
								{
									'name': '摇摆角kv值',
									'value': prk.TOWER[j].KV
								},
								{
									'name':'大风工况摇摆角(°)',
									'value':prk.TOWER[j].sway.WindA
								},
								{
									'name':'内过电压摇摆角(°)',
									'value':prk.TOWER[j].sway.OperationA
								},
								{
									'name':'外过电压摇摆角(°)',
									'value':prk.TOWER[j].sway.AtomosphereA
								},
								{
									'name':'带电作业摇摆角(°)',
									'value':prk.TOWER[j].sway.ElecA
								},
								{
									'name': '最大横担长度(m)',
									'value': prk.TOWER[j].Dist
								},
								{
									'name': '地线支架高度(m)',
									'value': prk.TOWER[j].upToTop
								},
								{
									'name': '上中导线高差(m)',
									'value': prk.TOWER[j].upToMid
								},
								{
									'name': '中下导线高差(m)',
									'value': prk.TOWER[j].minToDown
								},
								{
									'name': '其他附加属性',
									'value': toweraddTypeArr[prk.TOWER[j].typeEx - 1]
								},
								{
									'name': '最低塔正面根开(m)',
									'value': prk.TOWER[j].baseLw
								},
								{
									'name': '最低塔侧面根开(m)',
									'value': prk.TOWER[j].baseLl
								},
								{
									'name': '最高塔正面根开(m)',
									'value': prk.TOWER[j].baseHw
								},
								{
									'name': '最高塔侧面根开(m)',
									'value': prk.TOWER[j].baseHl
								},
								{
									'name': '杆塔分组号',
									'value': prk.TOWER[j].Group
								}];
							document.querySelector('#detailsTable').GM({
								gridManagerName: 'details',
								supportAutoOrder: false,
								supportDrag: false,
								supportCheckbox: false,
								ajaxData: {"data": data},
								columnData: columndataRight
							});
						}
					}
				}
			});
		})
	$('#gantatacai').click(function () {
			$('.edit').attr('disabled',true);
			$('#database').attr('disabled',false);
			$('#h2title').html($('#gantatacai').html());
			data = [];
			for (let i = 0; i < prk.TOWER.length; i++) {
				data.push({
					'id':i+1,
					'name':prk.TOWER[i].Name,
					'NO':prk.TOWER[i].No
				})
			}
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":data},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					for (let j = 0; j < prk.TOWER.length; j++) {
						if ( j === checkedList[0].NO){
							data = [];
							for (let k = 0; k < prk.TOWER[j].price.length; k++){
								data.push({
									'name':prk.TOWER[j].Name + '-' + prk.TOWER[j].price[k].High,
									'Weight':prk.TOWER[j].price[k].Weight,
									'BaseWight':prk.TOWER[j].price[k].BaseWight,
									'BaseM':prk.TOWER[j].price[k].BaseM,
									'JJ':prk.TOWER[j].price[k].JJ
								})
								document.querySelector('#detailsTable').GM({
									gridManagerName: 'details',
									supportAutoOrder: false,
									supportDrag: false,
									supportCheckbox: false,
									ajaxData: {"data": data},
									columnData: [{key: 'name', text: '杆塔名称'}, {key: 'Weight', text: '塔材(kg)'},{key: 'BaseWight', text: '基础钢材(kg)'}, {key: 'BaseM', text: '混凝土(吨)'}, {key: 'JJ', text: '串折算'}]
								});
							}

						}
					}
				}
			});
		})
	$('#jueyuancan').click(function () {
			$('.edit').attr('disabled',false);
			$('#database').attr('disabled',false);
			$('#h2title').html($('#jueyuancan').html());
			data = [];
			for (let i = 0; i < prk.INSULATE.length; i++) {
				data.push({
					'id':i+1,
					'name':prk.INSULATE[i].name
				})
			}
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":data},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					// console.log(checkedList);
					for (let j = 0; j < prk.INSULATE.length; j++) {
						if ( j === (checkedList[0].id - 1)){
							data = [];
							data = [
								{
									'name': '绝缘子串类型',
									'value': insulateArr[prk.INSULATE[j].type]
								},
								{
									'name': '单联双联',
									'value': sindouArr[prk.INSULATE[j].Join - 1]
								},
								{
									'name': '每联片数',
									'value': prk.INSULATE[j].Num
								},
								{
									'name': '无冰串重(kg)',
									'value': prk.INSULATE[j].Weight
								},
								{
									'name': '单片覆冰(kg)',
									'value': prk.INSULATE[j].IceWeight
								},
								{
									'name':'等效串长(m)',
									'value':prk.INSULATE[j].Length
								},
								{
									'name': '单片受风面积(m^2)',
									'value': prk.INSULATE[j].area
								},
								{
									'name': '金具受风折算系数',
									'value': prk.INSULATE[j].k
								},
								{
									'name': '绝缘子常年荷载安全系数',
									'value': prk.INSULATE[j].avergeK
								},
								{
									'name': '绝缘子最大荷载安全系数',
									'value': prk.INSULATE[j].maxK
								},
								{
									'name': '绝缘子断线工况安全系数',
									'value': prk.INSULATE[j].lineBrokeK
								},
								{
									'name':'绝缘子破坏荷载(kN)',
									'value':prk.INSULATE[j].Strength
								},
								{
									'name':'金具最大荷载安全系数',
									'value':prk.INSULATE[j].jjmaxK
								},
								{
									'name':'金具断线工况安全系数',
									'value':prk.INSULATE[j].jjlineBrokeK
								},
								{
									'name':'金具破坏荷载(kN)',
									'value':prk.INSULATE[j].jjStrength
								},
								{
									'name': 'V型串夹角(°)',
									'value': prk.INSULATE[j].angleV
								},
								{
									'name': '污秽区使用条件',
									'value': dirtyareaArr[prk.INSULATE[j].dirtyTpye]
								},
								{
									'name': '绝缘子材料',
									'value': insulateMateArr[prk.INSULATE[j].material]
								}];
							document.querySelector('#detailsTable').GM({
								gridManagerName: 'details',
								supportAutoOrder: false,
								supportDrag: false,
								supportCheckbox: false,
								ajaxData: {"data": data},
								columnData: columndataRight
							});
						}
					}
				}
			});
		})
	$('#jueyuancai').click(function () {
			$('.edit').attr('disabled',true);
			$('#database').attr('disabled',false);
			$('#h2title').html($('#jueyuancai').html());
			data = [];
			for (let i = 0; i < prk.INSULATE.length; i++) {
				data.push({
					'id':i+1,
					'name':prk.INSULATE[i].name
				})
			}
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":data},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					for (let j = 0; j < prk.INSULATE.length; j++) {
						if ( j === (checkedList[0].id - 1)){
							data = [];
							for (let k = 0; k < prk.INSULATE[j].metrial.length; k++){
								data.push({
									'name':prk.INSULATE[j].metrial[k].Name,
									'Type':prk.INSULATE[j].metrial[k].Type,
									'Count':prk.INSULATE[j].metrial[k].Count,
									'Weight':prk.INSULATE[j].metrial[k].Weight,
									'about':prk.INSULATE[j].metrial[k].about,
									'unit':prk.INSULATE[j].metrial[k].unit
								})
								document.querySelector('#detailsTable').GM({
									gridManagerName: 'details',
									supportAutoOrder: false,
									supportDrag: false,
									supportCheckbox: false,
									ajaxData: {"data": data},
									columnData: [{key: 'name', text: '材料名称'}, {key: 'Type', text: '材料型号'},{key: 'unit', text: '单位'},  {key: 'Weight', text: '单重'},{key: 'Count', text: '数量'}, {key: 'about', text: '备注'}]
								});
							}

						}
					}
				}
			});
		})
	$('#jiedican').click(function () {
			$('.edit').attr('disabled',false);
			$('#database').attr('disabled',false);
			$('#h2title').html($('#jiedican').html());
			data = [];
			for (let i = 0; i < prk.GCONNECT.length; i++) {
				data.push({
					'id':i+1,
					'name':prk.GCONNECT[i].Type
				})
			}
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":data},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					// console.log(checkedList);
					for (let j = 0; j < prk.GCONNECT.length; j++) {
						if ( j === (checkedList[0].id - 1)){
							data = [];
							data = [
								{
									'name': '适用塔型',
									'value': toweraddTypeArr[prk.GCONNECT[j].TowerType - 1]
								},
								{
									'name': '最小大地电阻率',
									'value': prk.GCONNECT[j].minResistance
								},
								{
									'name': '最大大地电阻率',
									'value': prk.GCONNECT[j].maxResistance
								}];
							document.querySelector('#detailsTable').GM({
								gridManagerName: 'details',
								supportAutoOrder: false,
								supportDrag: false,
								supportCheckbox: false,
								ajaxData: {"data": data},
								columnData: columndataRight
							});
						}
					}
				}
			});
		})
	$('#jiedicai').click(function () {
			$('.edit').attr('disabled',true);
			$('#database').attr('disabled',false);
			$('#h2title').html($('#jiedicai').html());
			data = [];
			for (let i = 0; i < prk.GCONNECT.length; i++) {
				data.push({
					'id':i+1,
					'name':prk.GCONNECT[i].Type
				})
			}
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":data},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					for (let j = 0; j < prk.GCONNECT.length; j++) {
						if ( j === (checkedList[0].id - 1)){
							data = [];
							for (let k = 0; k < prk.GCONNECT[j].metrial.length; k++){
								data.push({
									'name':prk.GCONNECT[j].metrial[k].Name,
									'Type':prk.GCONNECT[j].metrial[k].Type,
									'Count':prk.GCONNECT[j].metrial[k].Count,
									'Weight':prk.GCONNECT[j].metrial[k].Weight,
									'about':prk.GCONNECT[j].metrial[k].about,
									'unit':prk.GCONNECT[j].metrial[k].unit
								})
								document.querySelector('#detailsTable').GM({
									gridManagerName: 'details',
									supportAutoOrder: false,
									supportDrag: false,
									supportCheckbox: false,
									ajaxData: {"data": data},
									columnData: [{key: 'name', text: '材料名称'}, {key: 'Type', text: '材料型号'},{key: 'unit', text: '单位'},  {key: 'Weight', text: '单重'},{key: 'Count', text: '数量'}, {key: 'about', text: '备注'}]
								});
							}

						}
					}
				}
			});
		})
	$('#fangzhenchui').click(function () {
			$('#database').attr('disabled',true);
			$('.edit').attr('disabled',false);
			$('#h2title').html($('#fangzhenchui').html());
			data = [];
			for (let i = 0; i < prk.HAMMER.length; i++) {
				data.push({
					'id':i+1,
					'name':prk.HAMMER[i].Name
				})
			}
			document.querySelector('#outlineTable').GM({
				gridManagerName: 'outline',
				supportAutoOrder: false,
				supportDrag: false,
				checkboxConfig: {
					useRowCheck: true,
					useRadio: true
				},
				ajaxData: {"data":data},
				columnData: columndataLeft,
				checkedAfter: function (checkedList) {
					// console.log(checkedList);
					for (let j = 0; j < prk.HAMMER.length; j++) {
						if ( j === (checkedList[0].id - 1)){
							data = [{'name':'适用导地线','value': prk.HAMMER[j].lineName}];
							for (let i = 0; i < prk.HAMMER[j].fRNum.length; i++) {
								data.push({
									'name':'第'+(i+1)+'组规则',
									'value':prk.HAMMER[j].fRNum[i],
									'upLimit':prk.HAMMER[j].upLimit[i]
								})
							}
							document.querySelector('#detailsTable').GM({
								gridManagerName: 'details',
								supportAutoOrder: false,
								supportDrag: false,
								supportCheckbox: false,
								ajaxData: {"data": data},
								columnData:  [{key: 'name', text: '参数名称'}, {key: 'value', text: '型号/数量'},{key: 'upLimit', text: '适用档距上限'}]
							});
						}
					}
				}
			});
		})


	$('#save').click(function () {
			var prkinfo = new FormData();
			prkinfo.append("prk",JSON.stringify(prk));
			prkinfo.append("ProjectName",prjName);
			console.log("prkInfo",prkinfo);
			$.ajax({
				url: BASEURL+"/prksave", //提交的路径
				type: "post",       //提交方式
				data: prkinfo,    //提交的数据
				// dataType:"json",
				// async: false,
				// cache: false,
				contentType: false, // 告诉jQuery不要去设置Content-Type请求头
				processData: false,
				success: function (data) {
					alert("保存成功！");
					console.log(data);
				},
				error: function (errorMsg) {
					alert(errorMsg);
				}
			});
		})

	$('#savePrj').click(function () {
			$("#saveTower").click();
			$("#saveMap").click();
			var prjformData = new FormData();
			prjformData.append("prk",JSON.stringify(prk));
			prjformData.append("lao",JSON.stringify(lao));
			prjformData.append("PointFile","table.txt");
			prjformData.append("DemFile","");
			prjformData.append("ProjectName", prjName);
			$.ajax({
				url: BASEURL+"/projectsave", //提交的路径
				type: "post",       //提交方式
				data: prjformData,    //提交的数据
				// dataType:"json",
				contentType: false, // 告诉jQuery不要去设置Content-Type请求头
				processData: false,
				success: function (data) {
					console.log(data);
					alert("保存成功！");
				},
				error: function (errorMsg) {
					alert(errorMsg);
				}
			});
		})

	$('#saveMap').click(function () {

			let Map = {
				"mp":mp,
				"DEM":DEM,
				"cross":cross
			};
			var demgeoCal = {
				"ProjectName":prjName,
				"MapFileName":(MapFileName+".MAP").toString(),
				"JsonMap":JSON.stringify(Map)
			}
			console.log(Map);
			$.ajax({
				url: BASEURL+"/MapSaveObj", //提交的路径
				type: "post",       //提交方式
				data: demgeoCal,    //提交的数据
				//dataType:"json",
				success: function (data) {
					console.log(data);
				},
				error: function (errorMsg) {
					//alert(errorMsg);
					console.log(errorMsg);
				}
			});
		})
	/* 新建图幅 */
	$("#creatMap").click(function () {
		MapFileName = prompt("新建MAP名称");
		console.log(MapFileName);
		if(MapFileName){
			document.getElementById('span_id').innerHTML = prjName+"("+MapFileName+")";
			//input empty map
			scene.children.length = 0;
			console.log(scene);
			prjNameJSON = {"ProjectName":prjName};
			$.ajax({
				url: BASEURL+"/CreateMap", //提交的路径
				type: "post",       //提交方式
				data: prjNameJSON,    //提交的数据
				dataType:"json",
				//填充prk设计参数表格
				success: function (data) {
					console.log("mapdata",data);
					mp = data.mp;
					console.log("createMapFrameblank",mp);
					//yMin = 100; ydivision= 10; xdivision =100; verSize = 220;horSize =300; Gridsize =10;    //先设大小   再按distance/length 比例尺绘制
					ydivision=mp.m_HScale*mp.m_Grid/mp.m_CScale; xdivision = mp.m_DScale*mp.m_Grid/mp.m_CScale;Gridsize =mp.m_Grid;
					horSize=(mp.m_To-mp.m_From)*mp.m_CScale/(mp.m_Grid*mp.m_DScale)*Gridsize;  verSize = (mp.m_MapWidth-mp.m_Frame[14])*mp.m_HScale/(1000*ydivision)*Gridsize;
					xMin = mp.m_From;

					mainCanvas = document.querySelector("#iframe_box canvas");
					console.log(mainCanvas);
					initContent();
				},
				error: function (errorMsg) {
					//alert(errorMsg);
				}
			});
		}
	})
	/* 文件 */
	$("#fileManage").click(function () {
		layer.open({
			type:2,
			title:'工程文件',
			maxmin:true,
			area: ['300px', '250px'],
			content:'./html/ProjectManage.html',
			shade:0,
			success:function (layero,index) {
				console.log(layero,index);
				var body = layer.getChildFrame('body',index);
				console.log(body);
				let optionList;
				optionList =  body.find("select");
				$.ajax({
					url: BASEURL+"/directory/%20", //提交的路径
					type: "get",       //提交方式
					dataType:"json",
					success: function(data){
						console.log(data);
						for (let i = 0; i < data.length; i++) {
								var fileOption = new Option(data[i].name, i.toString());
								console.log(fileOption);
								optionList[0].options.add(fileOption);
						}
					}
				})

			}
		})
	})


	window.OpenPRJ = function (filedata,ProjectName){   //readfileToJson SIMPLE may cover original
		prjName  = ProjectName;
		document.getElementById('span_id').innerHTML = prjName;
		pile_tabledata = filedata.m_jPile;
		GridManager.setAjaxData(pile_tableId,{"data":pile_tabledata});
		$("#liPiletable").click();
		$("#tb_pile_calc").click();
		//Read PRK
		let prkform = new FormData();
		prkform.append("FileName", ProjectName+".PRK");
		prkform.append("ProjectName", ProjectName);
		$.ajax({
			url: BASEURL+"/ReadfileToJson", //提交的路径
			type: "post",       //提交方式
			data: prkform,    //提交的数据
			contentType: false, // 告诉jQuery不要去设置Content-Type请求头
			processData: false,
			success: function(prkdata){
				console.log(prkdata);
				prk = prkdata;

			},
			error: function (errorMsg) {
				alert(errorMsg);
			}
		})
		//读取PWF
		let pwfform = new FormData();
		pwfform.append("FileName", ProjectName+".PWF");
		pwfform.append("ProjectName", ProjectName);
		$.ajax({
			url: BASEURL+"/ReadfileToJson", //提交的路径
			type: "post",       //提交方式
			data: pwfform,    //提交的数据
			contentType: false, // 告诉jQuery不要去设置Content-Type请求头
			processData: false,
			success: function(pwfdata){
				console.log(pwfdata);
				towerlist = pwfdata.TOWERLIST;
				towerlist_tabledata = towerlist;
				m_start = 0;
				m_end = towerlist.length-1;
			},
			error: function (errorMsg) {
				alert(errorMsg);
			}
		})
		// $("#liTowerlisttable").click();
		// $("#tb-towerlist-calc").click();
	}

	window.OpenMap = function (filedata,ProjectName,FileName){
		prjName = ProjectName ;
		MapFileName = FileName;
		document.getElementById('span_id').innerHTML = prjName+"("+MapFileName+")";
		console.log("SectionMapSave",filedata);
		DEM= filedata.DEM;
		mp = filedata.mp;
		cross = filedata.cross;
		console.log("DEM,mp,cross updata",DEM,mp,cross);
		//$("#drawingpara").click();
		ydivision=mp.m_HScale*mp.m_Grid/mp.m_CScale; xdivision = mp.m_DScale*mp.m_Grid/mp.m_CScale;Gridsize =mp.m_Grid;
		horSize=(mp.m_To-mp.m_From)*mp.m_CScale/(mp.m_Grid*mp.m_DScale)*Gridsize;  verSize = (mp.m_MapWidth-mp.m_Frame[14])*mp.m_HScale/(1000*ydivision)*Gridsize;
		xMin = mp.m_From;
		drawDEM(DEM);
		MapCrossDraw(cross,false);  //cross added
		TowerDraw(towerlist_tabledata);
		window.initContent();
		drawGeo(pile_tabledata);
	}

	//draw  related
	/* 预设格网参数 */
	var verSize = 160;var horSize = 300; var ydivision=mp.m_HScale*mp.m_Grid/1000; var xdivision = mp.m_DScale*mp.m_Grid/1000;var Gridsize = mp.m_Grid;
	console.log("initial paremeter",ydivision,xdivision);
	var width,dis,gridHor,gridVer;
	var x = new Array();var y = new Array();
	var leftX = new Array();var leftY = new Array();
	var rightX = new Array();var rightY = new Array();
	var yMin = 100;var yMax = verSize;var xMax = 0; var xMin =0 ;
	var framegroup = new THREE.Group();
	let l_linegroup=new THREE.Group();let m_linegroup=new THREE.Group();let r_linegroup=new THREE.Group();
	//	let l_pointsgroup=new THREE.Group();let m_pointsgroup=new THREE.Group();let r_pointsgroup=new THREE.Group();
	let DEM_pgroup=new THREE.Group();
	var allChildren = [];var dem = [];	var towerList = [];
	var leftLineCor,rightLineCor,midLineCor,cornerCor;
	var corner = new Array();
	var show = true;
	var centerDem;//中心断面
	var mainCanvas = document.querySelector("#iframe_box canvas");//画布
	var DEM;

	//线、气象条件初始默认值
	var UseLine = {
				"name": "LGJX-400/35",
				"type": 0,
				"A": 425.24,
				"d": 26.82,
				"Tp": 103900,
				"p1": 1.349,
				"E": 65000,
				"a": 0.0000205,
				"num": 1
			};
	var UseWeather = {
				"name": "Ⅱ",
				"num": 12,
				"h": 15.0,
				"hs": 15.0,
				"alfa": 0.16,
				"B": 0.0,
				"TWI": [{
					"name": "平均气温",
					"t": 15.0,
					"v": 0.0,
					"b": 0.0
				},
					{
						"name": "最高气温",
						"t": 40.0,
						"v": 0.0,
						"b": 0.0
					},
					{
						"name": "最低气温",
						"t": -10.0,
						"v": 0.0,
						"b": 0.0
					},
					{
						"name": "最大风速",
						"t": 10.0,
						"v": 27.0,
						"b": 0.0
					},
					{
						"name": "最大覆冰",
						"t": -5.0,
						"v": 10.0,
						"b": 5.0
					},
					{
						"name": "安装情况",
						"t": 0.0,
						"v": 10.0,
						"b": 0.0
					},
					{
						"name": "操作情况",
						"t": 15.0,
						"v": 15.0,
						"b": 0.0
					},
					{
						"name": "大气有风",
						"t": 15.0,
						"v": 10.0,
						"b": 0.0
					},
					{
						"name": "大气无风",
						"t": 15.0,
						"v": 0.0,
						"b": 0.0
					},
					{
						"name": "最高线温",
						"t": 70.0,
						"v": 0.0,
						"b": 0.0
					},
					{
						"name": "检修工况",
						"t": 0.0,
						"v": 0.0,
						"b": 0.0
					},
					{
						"name": "事故工况",
						"t": 0.0,
						"v": 0.0,
						"b": 0.0
					}]
			};
	var section = {
				"name": "1",
				"starJ": "J2",
				"from": 0.0,
				"endJ": "J37(GL)",
				"to": 57641.0,
				"powerLine": "LGJX-400/35",
				"groundLine": "LGJX-50/30",
				"wertherName": "Ⅱ",
				"pLineK": 0.95,
				"pLineF": 2.500,
				"pLineC": 0.250,
				"gLineK": 1.000,
				"gLineF": 3.000,
				"gLineC": 0.250,
				"circuit": 1
			};

	var theLine = UseLine,theWeather = UseWeather;
	var designLine = 1;
	var xmin = 0; var xmax = 0;

		//清空当前画布
	function reclear(){
		for (let i = 0; i < allChildren.length; i++){
			framegroup.remove(allChildren[i]);
		}
		for (let i = 0; i < scene.children.length; i++){
			if (scene.children[i].name === "dem"||scene.children[i].name === "corner"){
				dem.push(scene.children[i]);
			}
			if (scene.children[i].name === "fixTower"||scene.children[i].name === "fixwire1" || scene.children[i].name === "fixwire2" ||scene.children[i].name === "fixwire3"||scene.children[i].name === "fixwire4"){
				towerList.push(scene.children[i]);
			}
		}
		for (let i = 0; i < dem.length; i++) {
			scene.remove(dem[i]);
		}
		for (let i = 0; i < towerList.length; i++) {
			scene.remove(towerList[i]);
		}
	}
	/* 将读取结果保存为坐标数组*/
	var midCoordinate = new Array();
	var leftCoordinate = new Array();
	var rightCoordinate = new Array();

	/* 默认关闭图纸参数和排杆设置框 */
	$(".frame_settings").hide();
	$(".tower_settings").hide();
	$("#exitBtn").click(function () {
		$(".frame_settings").hide();
	})
	$("#closeBtn").click(function () {
		$(".tower_settings").hide();
	})
	$("#menu-comments").click(function () {
		$(".frame_settings").show();
	})

	//图幅参数调整
	window.confirmOk = function() {
		width = $("#frameWid").val();
		dis = $("#sumDis").val();
		verSize = width * 150 /500;
		horSize = dis/10;
		for (let i = 0; i < allChildren.length; i++){
			framegroup.remove(allChildren[i]);
		}
		framegroup.remove(framegroup.children);
		window.initContent();
	}

	var scene, camera, renderer, controls, labelRenderer;
	var cameraX = 0 , cameraY = 0 , cameraZ=250;
	var sceneX = 0 , sceneY = 0, sceneZ = 0;
	var canvasdiv = document.getElementById('iframe_box');
	console.log(canvasdiv.offsetWidth);
	/* 场景 */
	function initScene() {
		scene = new THREE.Scene();
	}
	/* 相机 */
	var fov = 45;
	var near = 0.1;
	var far = 10000;  //  variable parameter by graph
	function initCamera() {
		camera = new THREE.PerspectiveCamera(fov, canvasdiv.offsetWidth / canvasdiv.offsetHeight, near, far);
		camera.position.set(cameraX, cameraY, cameraZ);
		camera.up.set(0,1,0);
		camera.lookAt(new THREE.Vector3(sceneX, sceneY, sceneZ));
	}
	/* 渲染器 */
	function initRender() {
		renderer = new THREE.WebGLRenderer({antialias: true});
		renderer.setSize(canvasdiv.offsetWidth, canvasdiv.offsetHeight);
		renderer.setClearColor(0xffffff,1.0);
		renderer.sortObjects = false; //渲染顺序按照add 顺序

		document.getElementById('iframe_box').appendChild(renderer.domElement);
		labelRenderer = new CSS2DRenderer();//文本二维渲染器
		labelRenderer.setSize( canvasdiv.offsetWidth, canvasdiv.offsetHeight);
		labelRenderer.domElement.style.position = 'absolute';
		labelRenderer.domElement.style.top = '0px';
		document.getElementById('iframe_box').appendChild( labelRenderer.domElement );
	}
	/* 灯光 */
	function initLight() {
		var ambientLight = new THREE.AmbientLight(0x333333);
		scene.add(ambientLight);
		var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
		directionalLight.position.set(100, 300, 200);
		scene.add(directionalLight);
	}
	/* 文本标注：文本内容/文本颜色/textpos/spritepos/旋转角度 */
	function  createSprite(text,color,x,y,posx,posy,rotate) {
		let canvas = document.createElement("canvas");
		let ctx = canvas.getContext("2d");
		ctx.fillStyle = color;
		ctx.font = "22px Arial";
		ctx.fillText(text,x,y);
		let texture = new THREE.Texture(canvas);
		texture.needsUpdate = true;
		let material = new THREE.SpriteMaterial({map:texture,transparent:true,rotation:rotate});
		let textObj = new THREE.Sprite(material);//使用Sprite显示文字
		textObj.scale.set(40, 20, 1);
		textObj.position.set(posx, posy , 0);
		return textObj;
	}
		window.createSpritelabel= function(text1,text2,text3,color,x,y,posx,posy,rotate) {
			let canvas = document.createElement("canvas");
			var ctx = canvas.getContext("2d");
			ctx.strokeStyle = "red";
			ctx.moveTo(x,y);
			ctx.lineTo(x,y+100);
			ctx.stroke();

			ctx.fillStyle = color;
			ctx.font = "22px Arial";
			ctx.textAlign="center";
			ctx.fillText(text1,x,y+20);
			ctx.textAlign="center";
			ctx.fillText(text2,x,y+40);
			ctx.textAlign="center";
			ctx.fillText(text3,x,y+60);

			let texture = new THREE.Texture(canvas);
			texture.needsUpdate = true;
			let material = new THREE.SpriteMaterial({map:texture,transparent:true,rotation:rotate});
			let textObj = new THREE.Sprite(material);//使用Sprite显示文字
			textObj.scale.set(40, 20, 1);
			textObj.position.set(posx, posy , 0);
			return textObj;
		}

	/* 图幅格网绘制 */
	window.initContent= function() {


		for (let i = 0; i < allChildren.length; i++){
			framegroup.remove(allChildren[i]);
		}
		// 外侧区域用white block 遮挡
		//draw white plan
		let left_block_geo =  new THREE.PlaneGeometry(5000,5000);
		let left_block_mat = new THREE.MeshBasicMaterial({color:0xffffff});
		let left_block =  new THREE.Mesh(left_block_geo,left_block_mat);
		//left_block.position.z = 100;
		left_block.position.verticesNeedUpdate =  true;
		left_block.position.x = -left_block.geometry.parameters.width/2;
		left_block.position.y =verSize/2;
		framegroup.add(left_block);
		let right_block_geo =  new THREE.PlaneGeometry(5000,5000);
		let right_block_mat = new THREE.MeshBasicMaterial({color:0xffffff});
		let right_block =  new THREE.Mesh(right_block_geo,right_block_mat);
		//right_block.position.z = 100;
		right_block.position.verticesNeedUpdate =  true;
		right_block.position.x =horSize+right_block.geometry.parameters.width/2;
		right_block.position.y = verSize/2;
		framegroup.add(right_block);

		//外轮廓
		var gridBound = new THREE.PlaneGeometry(horSize +30,verSize + mp.m_Frame[14]  );  //30 parameter replace?
		var material = new THREE.LineBasicMaterial({ color: 0x0000ff});
		var grid = new THREE.Mesh(gridBound,material);
		grid.position.x =(horSize -30)/2;
		grid.position.y = (verSize - mp.m_Frame[14])/2;
		var box = new THREE.BoxHelper( grid, 0x0000ff );
		framegroup.add(box);
		//居中
		var bbox = new THREE.Box3().setFromObject(box)
		cameraX = (bbox.max.x - bbox.min.x)/2;
		cameraY = (bbox.max.y + bbox.min.y)/2;
		console.log(cameraY);
		sceneX = cameraX; sceneY = cameraY;
		if (horSize >= verSize){cameraZ = (horSize - verSize)/2 + verSize + 120; }
		if (horSize < verSize){cameraZ = (verSize - horSize)/2 + horSize + 120; }
		camera.position.set(cameraX, cameraY, cameraZ);
		camera.lookAt(new THREE.Vector3(sceneX, sceneY, sceneZ));

		//左侧坐标轴
		var yAxisGeo = new THREE.Geometry();
		yAxisGeo.verticesNeedUpdate = true;
		yAxisGeo.vertices.push(new THREE.Vector3(-4,mp.m_Frame[9]-mp.m_Frame[14], 0));
		yAxisGeo.vertices.push(new THREE.Vector3(-4, verSize, 0));
		var yAxis = new THREE.Line(yAxisGeo, new THREE.LineBasicMaterial({
			color: 0xff0000
		}));
		framegroup.add(yAxis);

		//左侧高程刻度线
		var scalelineGeo = new THREE.Geometry();
		scalelineGeo.verticesNeedUpdate = true;
		scalelineGeo.vertices.push(new THREE.Vector3(-5,0,0));
		scalelineGeo.vertices.push(new THREE.Vector3(-4,0,0));
		for (let i = 0; i < verSize / Gridsize ; i++) {
			var scaleline = new THREE.Line(scalelineGeo,new THREE.LineBasicMaterial({color: 0x455454}));
			scaleline.position.y= i * Gridsize;
			framegroup.add(scaleline);
			var number = yMin+ i*ydivision;
			var text = number.toString();
			var scale = createSprite(text,"#000000",0,32,9,i * Gridsize-5,0);
			scale.name = "gaochengscale";
			framegroup.add(scale);
		}

		//横格网轴
		var horGeometry = new THREE.Geometry();
		horGeometry.verticesNeedUpdate = true;
		horGeometry.vertices.push(new THREE.Vector3(0, 0, 0)); //添加顶点
		horGeometry.vertices.push(new THREE.Vector3(horSize , 0, 0));
		var horizonGeo = new THREE.Geometry();
		horizonGeo.vertices.push(new THREE.Vector3(-30, 0, 0)); //添加顶点
		horizonGeo.vertices.push(new THREE.Vector3(horSize, 0, 0));

		if(mp.m_ShowMainGrid){
			for (var i = 0, len = verSize /Gridsize ; i <= len; i++) {
					gridHor = new THREE.Line(horGeometry, new THREE.LineBasicMaterial({color: 0x455454}));//用geometry和material创建line
					gridHor.position.y = i * Gridsize ; //设置line的位置
					gridHor.name = "gridHor";
					framegroup.add(gridHor);
			}
		}
		for(let j = 0; j<9;j++){
			var plangrid =  gridHor.clone();
			plangrid.name = "plangrid"+j.toString();
			plangrid.position.y=-(mp.m_Frame[14]-mp.m_Frame[j]);
			framegroup.add(plangrid);
		}

		var line = new THREE.Line(horizonGeo, new THREE.LineBasicMaterial({color: 0x455454}));
		line.position.y = - (mp.m_Frame[14]-mp.m_Frame[9]); //设置line的位置

		var gaocheng = createSprite(mp.m_HighSystem,"#ff0000",0,32,4.5,-55,Math.PI/2); //高程坐标系标签 位置自适应
		framegroup.add(gaocheng);
		var planLine = line.clone();//平面图下边界
		planLine.position.y = -(mp.m_Frame[14]-mp.m_Frame[5]);
		var planeText = createSprite("平面图","#ff0000",0,100,1.5,(line.position.y+planLine.position.y)/2,0);  //100 mframe[]
		framegroup.add(planeText);
		var textArr = ["            桩间距离","               里程","               档距","            杆塔位置","   耐张段长/代表档距"];
		for (let j = 4; j >=0 ; j--) {
			var disLine = line.clone();//桩间距离下边界
			disLine.position.y = -(mp.m_Frame[14]-mp.m_Frame[j]);
			framegroup.add(disLine);
			var note = createSprite(textArr[4-j],"#ff0000",0,60,-10,-(mp.m_Frame[14]-mp.m_Frame[j]),0);
			framegroup.add(note);
		}
		framegroup.add(planLine);
		framegroup.add(line);

		//纵格网轴
		var verGeometry = new THREE.Geometry();
		verGeometry.vertices.push(new THREE.Vector3(0, 0, 0)); //添加顶点
		verGeometry.vertices.push(new THREE.Vector3(verSize , 0, 0));
		var verBound = new THREE.Geometry();
		verBound.vertices.push(new THREE.Vector3(-mp.m_Frame[14], 0, 0)); //添加顶点
		verBound.vertices.push(new THREE.Vector3(verSize , 0, 0));
		var planGeo = new THREE.Geometry();
		planGeo.vertices.push(new THREE.Vector3(0,mp.m_Frame[8]-mp.m_Frame[14], 0)); //添加顶点
		planGeo.vertices.push(new THREE.Vector3(0, mp.m_Frame[6]-mp.m_Frame[14], 0));
		verGeometry.verticesNeedUpdate = true;
		verBound.verticesNeedUpdate = true;
		for (var i = 0, len = horSize / Gridsize; i < len; i++) {
			gridVer = new THREE.Line(verGeometry, new THREE.LineBasicMaterial({color: 0x324132}));
			var boundary = new THREE.Line(verBound, new THREE.LineBasicMaterial({color: 0x324132}));
			if (i === 0){
				boundary.position.x = i * Gridsize ;
				boundary.rotation.z = Math.PI / 2; //绕y轴旋转90度
				framegroup.add(boundary);
			}
			else {
				if(mp.m_ShowMainGrid){
					gridVer.position.x = i * Gridsize ;
					gridVer.rotation.z = Math.PI / 2; //绕y轴旋转90度
					gridVer.name="gridVer";
					framegroup.add(gridVer);
				}
			}
			var planVer = new THREE.Line(planGeo, new THREE.LineBasicMaterial({color: 0x324132}));
			planVer.name = "gridVer";
			planVer.position.x = i*Gridsize;
			//planVer.position.y = -(mp.m_Frame[14]-mp.m_Frame[]);
			framegroup.add(planVer);
			let x = createSprite((xMin+i*xdivision)/1000,"#ff0000",0,100,19+i*Gridsize,mp.m_Frame[4]-mp.m_Frame[14],0);

			framegroup.add(x);
		}
		//
		if(mp.m_SignFrame){
			console.log("mp signFrame show");
			var SignGeo = new THREE.Geometry();
			SignGeo.vertices.push(new THREE.Vector3(0,0,0)); //添加顶点
			SignGeo.vertices.push(new THREE.Vector3(70, 0, 0));
			var SignFrame = new THREE.Line(SignGeo, new THREE.LineBasicMaterial({color: 0x324132}));
			for(let i=0 ;i<5;i++){
				let SignFrame_hor = SignFrame.clone();
				SignFrame_hor.position.x = horSize-70;
				SignFrame_hor.position.y = verSize-10*i;
				framegroup.add(SignFrame_hor);
			}
			var SignGeo = new THREE.Geometry();
			SignGeo.vertices.push(new THREE.Vector3(0,0,0)); //添加顶点
			SignGeo.vertices.push(new THREE.Vector3(0, -40, 0));
			var SignFrame = new THREE.Line(SignGeo, new THREE.LineBasicMaterial({color: 0x324132}));
			for(let i=0 ;i<2;i++){
				let SignFrame_ver = SignFrame.clone();
				SignFrame_ver.position.x = horSize-70+i*20;
				SignFrame_ver.position.y = verSize;
				framegroup.add(SignFrame_ver);
			}

			//sprite
			var note = createSprite(" 图号 ","#ff0000",10,60,horSize-30,verSize-10,0);
			note.scale.set(80,40,1);
			framegroup.add(note);
			var note = createSprite(" 组长 ","#ff0000",10,60,horSize-30,verSize-20,0);
			note.scale.set(80,40,1);
			framegroup.add(note);
			var note = createSprite(" 设计 ","#ff0000",10,60,horSize-30,verSize-30,0);
			note.scale.set(80,40,1);
			framegroup.add(note);
			var note = createSprite(" 校核 ","#ff0000",10,60,horSize-30,verSize-40,0);
			note.scale.set(80,40,1);
			framegroup.add(note);


		}


		allChildren = [];
		for (let i = 0; i < framegroup.children.length; i++) {
			allChildren.push(framegroup.children[i]);
		}

		//图纸参数设置框
		$("#frameset").click(function () {
			$(".frame_settings").show();

			width = $("#frameWid").val();
			let index = 0;
			var check = $("#showGrid");//控制格网隐藏
			check.click(function () {
				index ++ ;
				let grid = [];
				for (let i = 0; i<framegroup.children.length; i++){
					if (framegroup.children[i].name === "gridVer"||framegroup.children[i].name === "gridHor") {
						grid.push(framegroup.children[i]);
					}
				}
				if (index % 2 === 1){
					for (let i = 0; i < grid.length; i++) {
						grid[i].material = new THREE.LineBasicMaterial({color: 0xffffff});//隐藏格网
					}
				}
				if (index % 2 === 0){
					for (let i = 0; i < grid.length; i++) {
						grid[i].material = new THREE.LineBasicMaterial({color: 0x324132});//显示格网
					}
				}
			})
		})
		scene.add(framegroup);
	}

	var tempDif = 0;
	var dif = 0;
	/* DEM绘制函数 */
	window.drawDEM=function (DEM){
		console.log(scene.children ,"drawscenechildren");
		console.log(m_linegroup.children.length,"m_linegroup length");
		if(m_linegroup.children.length!=0){

			// for ( let i = 0; i < m_linegroup.children.length; i ++ ) {
			//
			// 	const object = m_linegroup.children[ i ];
			//
			// 	object.parent = null;
			//
			// 	//object.dispatchEvent( _removedEvent );
			// }
			m_linegroup.children.length = 0;    //清空group   clear（）not defined  altered
		}
		if(r_linegroup.children.length!=0){r_linegroup.children.length = 0;}
		if(l_linegroup.children.length!=0){l_linegroup.children.length = 0;}
		if(DEM_pgroup.children.length!=0){DEM_pgroup.children.length = 0;}



			console.log(m_linegroup.children.length,"after remove ");


		yMin=DEM.MID[0].Section[0].z
		for(let i=0;i<DEM.MID.length;i++){
			for(let j=0;j<DEM.MID[i].Section.length;j++){
				if(yMax<DEM.MID[i].Section[j].z){yMax=DEM.MID[i].Section[j].z;}
				if(yMin>DEM.MID[i].Section[j].z){yMin=DEM.MID[i].Section[j].z;}
			}
		}
		for(let i=0;i<DEM.LEFT.length;i++){
			for(let j=0;j<DEM.LEFT[i].Section.length;j++){
				if(yMax<DEM.LEFT[i].Section[j].z){yMax=DEM.LEFT[i].Section[j].z;}
				if(yMin>DEM.LEFT[i].Section[j].z){yMin=DEM.LEFT[i].Section[j].z;}
			}
		}
		for(let i=0;i<DEM.RIGHT.length;i++){
			for(let j=0;j<DEM.RIGHT[i].Section.length;j++){
				if(yMax<DEM.RIGHT[i].Section[j].z){yMax=DEM.RIGHT[i].Section[j].z;}
				if(yMin>DEM.RIGHT[i].Section[j].z){yMin=DEM.RIGHT[i].Section[j].z;}
			}
		}

		//起算标记  向下取整
		yMin =  (parseInt(yMin/ydivision))*ydivision;
		xMin =  (parseInt(xMin/xdivision))*xdivision;
		xMax = parseInt(DEM.MID[DEM.MID.length-1].Section[DEM.MID[DEM.MID.length-1].Section.length-1].x);


			//tempDif = yMax - yMin;
		//dif = (parseInt((yMax - yMin)/10) + 2 ) * 10;

		// xMax = parseInt(DEM.RIGHT[DEM.RIGHT.length-1].Section[DEM.RIGHT[DEM.RIGHT.length-1].Section.length-1].x); //X last element
		// horSize = xMax/xdivision*Gridsize;      //+add  border
		// verSize = (yMax - yMin)/ydivision*Gridsize;  //+add  border

		console.log(horSize,verSize,xdivision,ydivision,xMin,yMin,Gridsize,"frame");    //坐标系转换


		// draw object group;
		// 中心断面 object

		//m_line.length=DEM.MID.length;
		if(DEM.MID.length>0){
			var m_material = new THREE.LineBasicMaterial( { color: 0x000000 } );
			var mp_material = new THREE.PointsMaterial({color:0x888888,size:2.0});
			var m_line = new Array();
			var m_points=new Array();
			for(let i=0;i<DEM.MID.length;i++){
				var m_vertice = new THREE.Geometry();
				for(let j=0;j<DEM.MID[i].Section.length;j++) {
					m_vertice.vertices.push(new THREE.Vector3((DEM.MID[i].Section[j].x - xMin)/ xdivision*Gridsize, (DEM.MID[i].Section[j].z - yMin)/ydivision*Gridsize, 0));
				}
				m_line[i]= new THREE.Line(m_vertice,m_material);m_line[i].name = "MID"+"-"+i.toString();
				m_points[i] = new THREE.Points(m_vertice,mp_material);
				m_points[i].visible=false;
				m_linegroup.add(m_line[i]);
				DEM_pgroup.add(m_points[i]);
			}
			scene.add(m_linegroup);

		}

		//scene.add(DEM_pgroup);
		if(DEM.LEFT.length>0){
			var l_material = new THREE.LineDashedMaterial( { color: 0x0000ff ,dashSize:3, gapSize:1} );
			var lp_material = new THREE.PointsMaterial({color:0x888888,size:2.0});
			var l_line = new Array();
			var l_points= new Array();
			l_line.length=DEM.LEFT.length;
			for(let i=0;i<DEM.LEFT.length;i++){
				var l_vertice = new THREE.Geometry();
				for(let j=0;j<DEM.LEFT[i].Section.length;j++) {
					l_vertice.vertices.push(new THREE.Vector3((DEM.LEFT[i].Section[j].x -xMin)/ xdivision*Gridsize, (DEM.LEFT[i].Section[j].z - yMin)/ydivision*Gridsize, 0));
				}
				l_line[i]= new THREE.Line(l_vertice,l_material);l_line[i].name = "LEFT"+"-"+i.toString();
				l_line[i].computeLineDistances(); //for DashedMaterial
				l_linegroup.add(l_line[i]);
				l_points[i] = new THREE.Points(l_vertice,lp_material);
				l_points[i].visible=false;
				DEM_pgroup.add(l_points[i]);
			}
			scene.add(l_linegroup);
		}

		//scene.add(DEM_pgroup);
		if(DEM.RIGHT.length>0){
			var r_material = new THREE.LineDashedMaterial( { color: 0x00ff00,dashSize:2,gapSize:2 } );
			var rp_material = new THREE.PointsMaterial({color:0x888888,size:2.0});
			var r_line = new Array();
			var r_points= new Array();
			r_line.length=DEM.RIGHT.length;
			for(let i=0;i<DEM.RIGHT.length;i++){
				var r_vertice = new THREE.Geometry();
				for(let j=0;j<DEM.RIGHT[i].Section.length;j++) {
					r_vertice.vertices.push(new THREE.Vector3((DEM.RIGHT[i].Section[j].x-xMin) / xdivision*Gridsize, (DEM.RIGHT[i].Section[j].z - yMin)/ydivision*Gridsize, 0));
				}
				r_line[i]= new THREE.Line(r_vertice,r_material);r_line[i].name = "RIGHT"+"-"+i.toString();
				r_line[i].computeLineDistances(); //for DashedMaterial
				r_linegroup.add(r_line[i]);
				r_points[i] = new THREE.Points(r_vertice,rp_material);
				r_points[i].visible=false;
				DEM_pgroup.add(r_points[i]);
			}
			scene.add(r_linegroup);
		}

		scene.add(DEM_pgroup);

	}
	/* 转角投影线绘制函数 */
	window.drawGeo= function (cornerCor){
		for(let i = 0 ;i<scene.children.length;i++){
			if(scene.children[i].name == "ProjectLine"){scene.remove(scene.children[i]);}
		}
		var cornerMaterial = new THREE.LineBasicMaterial({color:0xff0000});
		let GeoGroup = new THREE.Group();
		GeoGroup.name ="ProjectLine"
		for (let i = 0 ; i <cornerCor.length ; i++){
			if(cornerCor[i].dist>=xMin&&cornerCor[i].dist<=xMax+1){
				var cornerGeo = new THREE.Geometry();
				cornerGeo.vertices.push(new THREE.Vector3((cornerCor[i].dist-xMin)/xdivision*Gridsize,(cornerCor[i].z-yMin)/ydivision*Gridsize,0));
				cornerGeo.vertices.push(new THREE.Vector3((cornerCor[i].dist-xMin)/xdivision*Gridsize,mp.m_Frame[9]-mp.m_Frame[14],0));
				var cornerLine = new THREE.Line(cornerGeo,cornerMaterial);cornerLine.name = "cornerLine-"+i.toString();
				// console.log(cornerLine);
				GeoGroup.add(cornerLine);
			}
		}
		scene.add(GeoGroup);
	}

	$('#inputCorner').click(function () {
		/* 转角投影线绘制 */
		for(let i=0;i<scene.children.length;i++){
			if(scene.children[i].name ==="ProjectLine"){
			scene.remove(scene.children[i]);
			console.log("ProjectLineRemove",scene);
			return true;
			}
		}
		 drawGeo(pile_tabledata);
		console.log("ProjectLineadd",scene);
	})

		/* 悬链线相关函数 */
		window.ComputeLoad = function() {
			var a0=1;							//风压不均匀系数
			var p=1.2255;						//空气密度 ρ
			var g=9.80665;						//重力加速度 ｍ/ｓ^2
			var Usc = 1.0;						//体型系数
			var B =   1.0;						//覆冰时风荷载增大系数
			var Uz =  1.0;						//风速高度变化系数
			var Bc =  1.0;						//风荷载调整系数βc

			for (let i = 0; i < theWeather.num; i++) {
				let v = theWeather.TWI[i].v; //风速
				let b = theWeather.TWI[i].b; //覆冰
				//体型系数取值
				if (b>0 || theLine.d < 17.0){
					Usc = 1.2;
				}
				else {Usc = 1.1;}

				//风速高度变化系数取值
				if (i == 3){
					Uz = Math.pow(theWeather.h / 10, theWeather.alfa * 2);
				}else {
					Uz = 1;
				}

				//覆冰时风荷载增大系数取值
				if (b==5) B = 1.1;
				else if (b ==10) B = 1.2;
				else if (b == 15) B = 1.3;
				else if (b >= 20) B = 1.5;
				else B = 1;

				//风压不均匀系数及风荷载调整系数取值
				if (designLine ==1){
					if (v<20) a0 =1;
					else if (v >= 20&&v<27) a0 = 0.85;
					else if (v>= 27&&v<31.5) a0 = 0.75;
					else a0 = 0.70;
				}
				else if(designLine == 0){
					if (v<20) a0 =1;
					else if (v >= 20&&v<27) a0 = 0.75;
					else if (v>= 27) a0 = 0.61;
				}
				else if (designLine > 10){
					if(designLine<=200)
						a0 = 0.80;
					else if(designLine>200 && designLine<=250)
						a0= 0.80 -(designLine-200)/50*(0.80-0.74);
					else if(designLine>250 && designLine<=300)
						a0 =0.74 -(designLine-250)/50*(0.74-0.70);
					else if(designLine >300 && designLine<=350)
						a0 =0.70 -(designLine-300)/50*(0.70-0.67);
					else if(designLine >350 && designLine<=400)
						a0 =0.67 -(designLine-350)/50*(0.67-0.65);
					else if(designLine >400 && designLine<=450)
						a0 =0.65 -(designLine-400)/50*(0.65-0.63);
					else if(designLine >450 && designLine<=500)
						a0= 0.63 -(designLine-450)/50*(0.63-0.62);
					else if(designLine >500 && designLine<550)
						a0 =0.62 -(designLine-500)/50*(0.62-0.61);
					else if(designLine >=550)
						a0 = 0.61;
				}

				theWeather.TWI[i].P1 = theLine.p1*g;										//自荷载
				theWeather.TWI[i].P2 = 0.9*Math.PI*b*(b+theLine.d)*g*1E-3;						//冰荷载
				theWeather.TWI[i].P3 = theWeather.TWI[i].P1+theWeather.TWI[i].P2;			//自荷载加冰荷载
				theWeather.TWI[i].P4 = a0*v*v/1600*Uz*Usc*Bc*theLine.d ;					//无冰风荷载
				theWeather.TWI[i].P5 = a0*v*v/1600*Uz*Usc*Bc*(theLine.d+2*b)*B;			//覆冰时风荷载
				theWeather.TWI[i].P6 = Math.sqrt(theWeather.TWI[i].P1 * theWeather.TWI[i].P1 + theWeather.TWI[i].P4 * theWeather.TWI[i].P4);							//无冰时综合荷载
				theWeather.TWI[i].P7 = Math.sqrt(theWeather.TWI[i].P3 * theWeather.TWI[i].P3 + theWeather.TWI[i].P5 * theWeather.TWI[i].P5);
				theWeather.TWI[i].angle = Math.atan(theWeather.TWI[i].P5/theWeather.TWI[i].P3);	//风偏角的弧度值
				theWeather.TWI[i].angle = theWeather.TWI[i].angle/Math.PI *180.0;				//风偏角的度数值βο
			}
		}
		window.initializeData = function(UseWeather,UseLine,u,lineDesign){
			theWeather = UseWeather;
			theLine =    UseLine;
			if (theLine.type!= 0){
				// theWeather.TWI[4].b = theWeather.TWI[4].b + prk.PRIMARY.dIce;(出错地点）
				theWeather.TWI[4].b = 5 + prk.PRIMARY.dIce;
				//console.log("weather4b",theWeather.TWI[4].b);
			}
			theLine.F = theLine.F/u;
			theLine.S_p = theLine.Tp*theLine.k/theLine.A;
			theLine.S_m = theLine.S_p/theLine.F;
			theLine.S_a = theLine.S_p * theLine.C;

			theWeather.h = prk.PRIMARY.windH;
			theWeather.alfa =prk.PRIMARY.alfa;

			designLine = lineDesign;
			ComputeLoad();
		}
		window.FindUsingSection = function(x) {
			x= x+5;
			for(let i=0;i<prk.SECTION.length;i++)
			{
				if(x>=prk.SECTION[i].from && x<=prk.SECTION[i].to)
					return i;
			}
			return -1;
		}
		window.FindUsingLine = function(i) {
			for(let j=0;i >-1 && j<prk.CONDUCTOR.length;j++)
			{
				if(prk.SECTION[i].powerLine==prk.CONDUCTOR[j].name)
					return j;
			}
			return -1;
		}
		window.FindUsingGLine = function(i) {
			for(let j=0;i >-1 && j<prk.CONDUCTOR.length;j++)
			{
				if(prk.SECTION[i].groundLine==prk.CONDUCTOR[j].name)
					return j;
			}
			return -1;
		}
		window.FindUsingWeather = function(i) {
			for(let j=0;i >-1 && j<prk.WEATHER.length;j++)
			{
				if(prk.SECTION[i].wertherName == prk.WEATHER[j].name)
					return j;
			}
			return -1;
		}
		window.FindTower = function(tower){
			for(let i=0;i<prk.TOWER.length;i++)
			{
				if(tower.TowerType==prk.TOWER[i].Name
						&& tower.TowerHigh>=prk.TOWER[i].StartHigh && tower.TowerHigh<=prk.TOWER[i].EndHigh)
					return i;
			}
			return -1;
		}
		window.initializeDataBool = function(x,u,isPower,designLine){
			UseLine = prk.CONDUCTOR[0];
			UseWeather = prk.WEATHER[0];
			section = prk.SECTION[0];
			let l = 0,w=0,gl = 0,SectionNo = 0;
			SectionNo = FindUsingSection(x);
			if (SectionNo <0) return false;
			section = prk.SECTION[SectionNo];
			if (isPower){
				l = FindUsingLine(SectionNo);
				if(l<0)	return false;
				UseLine = prk.CONDUCTOR[l];
				UseLine.k = section.pLineK;
				UseLine.F = section.pLineF;
				UseLine.C = section.pLineC;
			}
			else {
				l = FindUsingGLine(SectionNo);
				if(l<0) return false;
				UseLine = prk.CONDUCTOR[l];
				UseLine.k = section.gLineK;
				UseLine.F = section.gLineF;
				UseLine.C = section.gLineC;
			}

			w = FindUsingWeather(SectionNo);
			if(w<0) return false;
			UseWeather = prk.WEATHER[w];

			initializeData(UseWeather,UseLine,u,designLine);
			return true;
		}
		window.GetCtlCondition = function(l) {
			let ctrl;
			let max_Fmx = -99999999;
			for (let i = 0; i < theWeather.num && i < 5; i++) {
				if (i === 0){
					theWeather.TWI[i].Fmx = theLine.E * Math.pow(theWeather.TWI[i].P7/theLine.A * l,2)/(24*Math.pow(theLine.S_a,2)) - theLine.S_a - theLine.a * theLine.E * theWeather.TWI[i].t;
				}else {
					theWeather.TWI[i].Fmx = theLine.E * Math.pow(theWeather.TWI[i].P7/theLine.A * l,2.0) / (24.0*Math.pow(theLine.S_m,2.0)) - theLine.S_m - theLine.a*theLine.E* theWeather.TWI[i].t;
				}

				if(theWeather.TWI[i].Fmx>max_Fmx)							//获取当前代表档距下的控制条件
				{
					max_Fmx = theWeather.TWI[i].Fmx;
					ctrl = i;
				}
			}
			return ctrl;
		}
		window.GetStrain = function(l,cosa,condition) {
			let S = 0;
			let ctrl = GetCtlCondition(l);
			let b,d;
			let Sm,rm,r,E,a;
			if (ctrl == condition){return ctrl == 0?theLine.S_a:theLine.S_m;}
			if (ctrl == 0){Sm = theLine.S_a;}
			else Sm = theLine.S_m;
			rm = theWeather.TWI[ctrl].P7/theLine.A;
			E = theLine.E;
			a = theLine.a;
			r = theWeather.TWI[condition].P7/theLine.A;
			b = Sm - rm*rm*l*l*E*Math.pow(cosa,3)/(24*Sm*Sm) + a*E*cosa*(theWeather.TWI[ctrl].t - theWeather.TWI[condition].t);
			d = r*r*l*l*E*Math.pow(cosa,3)/24;
			S = GetEquationValue(1,-b,0,-d,9999);
			return S;
		}
		window.GetEquationValue = function(a,b,c,d,maxX) {
			let A,B,C,delta;
			let x0=0,x1,x2,x3;
			let zero = 1E-4;
			A = b*b-3.0*a*c;
			B = b*c -9.0*a*d;
			C = c*c - 3.0*b*d;
			delta = B*B - 4*A*C;
			if(Math.abs(A-B)<zero && Math.abs(A)<zero)
				x0 = -b/3.0/a;
			else if(Math.abs(delta)<zero)
			{
				let K;
				K = B/A;
				x1 = -b/a+K;
				x2 = -K/2.0;

				if(x1>0 && x1<=maxX)
					x0 = x1;
				else if(x2>0 && x2<=maxX)
					x0 = x2;
			}
			else if(delta>0)
			{
				let Y1,Y2;
				Y1 = A*b + 3.0*a*(-B+Math.sqrt(delta))/2.0;
				Y2 = A*b + 3.0*a*(-B-Math.sqrt(delta))/2.0;
				let t1 = Math.pow( Math.abs(Y1) ,1.0/3.0 );
				let t2 = Math.pow( Math.abs(Y2) ,1.0/3.0 );
				if(Y1<0) t1 = -t1;
				if(Y2<0) t2 = -t2;
				x0 = ( -b-t1-t2 ) / (3.0*a);

			}
			else if(delta<0)
			{
				let sita,T;
				T = (2.0*A*b-3.0*a*B) / (2.0*Math.pow(A,3.0/2.0));
				sita = Math.acos(T);
				x1 = ( -b-2.0*Math.sqrt(A)*Math.cos(sita/3.0) )/3.0/a;
				x2 = ( -b+Math.sqrt(A)*(Math.cos(sita/3.0)+Math.sqrt(3.0)*Math.sin(sita/3.0)) ) /(3.0*a) ;
				x3 = ( -b+Math.sqrt(A)*(Math.cos(sita/3.0)-Math.sqrt(3.0)*Math.sin(sita/3.0)) ) /(3.0*a) ;
				if(x1>0 && x1<=maxX)
					x0 = x1;
				else if(x2>0 && x2<=maxX)
					x0 = x2;
				else if(x3>0 && x3<=maxX)
					x0 = x3;
			}
			return x0 ;
		}
		window.GetMaxK = function(l,cosa,currentConditon) {
			let ctrl = GetCtlCondition(l) ;
			let S;let max_K = -99999999;
			for (let i = 0; i < 5; i++) {
				S = GetStrain(l,cosa,i);
				if (theWeather.TWI[i].P7 / (2.0*S*theLine.A) >max_K){
					currentConditon = i;
					max_K = theWeather.TWI[i].P7 / (2.0*S*theLine.A);
				}
			}
			return max_K;
		}
		window.GetMinK = function(l,cosa,currentConditon){
			let ctrl = GetCtlCondition(l);								//控制条件序号
			let S;													//应力
			let min_K = 99999999;									//最大K值
			for(let j = 0;j<5;j++)										//气象条件下的电线应力（力学计算P118）
			{
				S = GetStrain(l,cosa,j);								//计算应力
				if(theWeather.TWI[j].P7 / (2.0*S*theLine.A) <min_K)
				{
					currentConditon = j;
					min_K = theWeather.TWI[j].P7 / (2.0*S*theLine.A);
				}
			}
			return min_K;
		}
		window.GetLoad = function(condition,no) {
			if(no==1)
				return theWeather.TWI[condition].P1;
			else if(no==2)
				return theWeather.TWI[condition].P2;
			else if(no==3)
				return theWeather.TWI[condition].P3;
			else if(no==4)
				return theWeather.TWI[condition].P4;
			else if(no==5)
				return theWeather.TWI[condition].P5;
			else if(no==6)
				return theWeather.TWI[condition].P6;
			else if(no==7)
				return theWeather.TWI[condition].P7;
			else
				return 0;
		}
		window.FindInsulate = function(insulateName) {
			if(insulateName=="")
				return -1;
			for(let i=0;i<prk.INSULATE.length;i++)
			{
				if(insulateName==prk.INSULATE[i].name)
					return i;
			}
			return -1;
		}
		window.GetDown2Top = function(towerType) {
			for(let i=0;i<prk.TOWER.length;i++)
			{
				if(prk.TOWER[i].Name==towerType)
					return prk.TOWER[i].upToMid+prk.TOWER[i].upToTop+prk.TOWER[i].minToDown;
			}
			return 0;
		}
		window.ComputeHugeHigh = function() {
			for (let i = m_start; i <= m_end; i++) {
				let down2top = GetDown2Top(towerlist[i].TowerType);
				//计算杆塔的悬点高程
				if(towerlist[i].Status==0)
					towerlist[i].hugeHigh = towerlist[i].High + towerlist[i].Base + towerlist[i].TowerHigh - towerlist[i].InsulatorLength;
				else
					towerlist[i].hugeHigh = towerlist[i].High + towerlist[i].Base + towerlist[i].TowerHigh ;
				//地线悬点高
				towerlist[i].hugeGround = towerlist[i].High + towerlist[i].Base + towerlist[i].TowerHigh + down2top;
			}

			ComputeLk();
			ComputeK2();
			ComputeLhLv();
			ComputeGK2();
		}
		window.ComputeLk = function() {
			let start,end;//耐张段起始转角，终止转角
			let l,x,y,cosb,length,t,cosBk;
			start = m_start;
			end = m_end;
			while (start < m_end){
				end = start + 1;
				if (end < 0) end = m_end;

				length = 0; x = 0; y = 0; t = 0;
				for (let i = start; i < end; i++) {
					length += (towerlist[i+1].Distance - towerlist[i].Distance);//towerlist l2
					cosb = Math.cos(Math.atan((towerlist[i+1].hugeHigh - towerlist[i].hugeHigh)/(towerlist[i+1].Distance - towerlist[i].Distance)));
					t += (towerlist[i+1].Distance - towerlist[i].Distance)/cosb/cosb;
					x += Math.pow((towerlist[i+1].Distance - towerlist[i].Distance),3) * Math.pow(cosb,2);
					y += (towerlist[i+1].Distance - towerlist[i].Distance)/cosb;
				}
				cosBk = y/t;
				if (end - start >1) l = Math.sqrt(x/y) / cosBk;
				else l = length;

				for (let i = start; i < end; i++) {
					towerlist[i].Lk = l;
					towerlist[i].L = length;
					towerlist[i].cosa = cosBk;
					if (((end - start) == 1) && ((towerlist[i+1].Distance - towerlist[i].Distance) <= prk.PRIMARY.InsularMaxL)){
						towerlist[i].bInsular = true;
					}
					else{
						towerlist[i].bInsular = false;
						towerlist[i].constant = 0;
					}
				}
				start = end;//从终止转角继续查找下一个转角
			}
		}
		window.ComputeIsolate = function(t1,t2,k,constA,kMaxT,constMaxT) {
			//风压高度变化系数
			let Kh = Math.pow(prk.PRIMARY.windH/10,prk.PRIMARY.alfa);
			//判别函数值 线长系数 应力 弧垂
			let F = [],K = [],S = [],f = [];
			//档距
			let m_l = t2.Distance-t1.Distance;
			//绝缘子串参数
			let m_length,m_weights,m_weight,m_area;
			//控制应力
			let m_Tav,m_Tmax,m_Ttract;
			//分裂数
			let n = theLine.num;
			let insulateName ;
			if(t1.InsulatePA!="")
				insulateName =t1.InsulatePA;
			else if(t1.InsulatePB!="")
				insulateName =t1.InsulatePB;
			else if(t2.InsulatePA!="")
				insulateName =t2.InsulatePA;
			else if(t2.InsulatePB!="")
				insulateName =t2.InsulatePB;
			let indexIsolate = FindInsulate(insulateName);
			if(indexIsolate !=-1)
			{
				m_length = prk.INSULATE[indexIsolate].Length;
				m_weight = prk.INSULATE[indexIsolate].Weight;
				m_weights = prk.INSULATE[indexIsolate].Weight +prk.INSULATE[indexIsolate].IceWeight*prk.INSULATE[indexIsolate].Num*prk.INSULATE[indexIsolate].Join;
				m_area = prk.INSULATE[indexIsolate].area*prk.INSULATE[indexIsolate].Num*prk.INSULATE[indexIsolate].Join;
			}
			else
			{
				m_length = t1.InsulatorLength;
				m_weight = 200;
				m_weights =300;
				m_area =   1.0;
			}
			m_Tav =  theLine.Tp*theLine.k*theLine.C;
			m_Tmax = theLine.Tp*theLine.k/theLine.F;
			m_Ttract = m_Tmax;
			let bata = Math.atan((t2.hugeHigh-t1.hugeHigh)/m_l);
			let cl0 = m_length*Math.cos(bata);
			let deltaL = 0;
			let A = theLine.A;
			let E = theLine.E;
			let a = theLine.a;
			let g = 9.8;
			let G =0 ;
			let ctrl = 0;
			let ctrlK=0,Fmax=-99999;
			let l1,W1,rb,tz,r,rs,T,aa;
			for(let i=0;i<10;i++)
			{
				r = GetLoad(i,7)/A;
				if(theWeather.TWI[i].b>0)
					G = Math.sqrt((m_weights*g)*(m_weights*g),(m_area*Math.pow(theWeather.TWI[i].v*Kh,2)/1.600)*(m_area*Math.pow(theWeather.TWI[i].v*Kh,2)/1.600))/n;
				else
					G = Math.sqrt((m_weight* g)*(m_weight* g),(m_area*Math.pow(theWeather.TWI[i].v*Kh,2)/1.600)*(m_area*Math.pow(theWeather.TWI[i].v*Kh,2)/1.600))/n;
				if( i==5)		//安装工况 施工观测弧垂 一端有串
				{
					S[i] = m_Ttract/A;
					l1 = m_l- cl0;
					W1 = l1*r/Math.cos(bata);
					rb = r/Math.cos(bata);
					tz = l1*(l1+3*cl0) + 6*cl0*G/(A*W1*rb)*(W1+2.0*G/3.0/A) - 3*cl0*cl0*Math.pow(W1+G/A,2)/(m_l*W1*rb);
					K[i] = r*r*E*Math.pow(Math.cos(bata),3)/24 *tz;
					deltaL = prk.PRIMARY.pLTract;
				}
				else			// 竣工情况 两端有串
				{
					if(i==0)
						S[i] = m_Tav/A;
					else
						S[i] = m_Tmax/A;
					l1 = m_l- 2*cl0;
					W1 = l1 * r/Math.cos(bata);
					rb = r/Math.cos(bata);
					tz =  l1*(l1+6*cl0) + 12*G*cl0*(W1+2.0*G/3.0/A)/(W1*rb*A);
					K[i] = r*r*E*Math.pow(Math.cos(bata),3)/24 *tz;
					deltaL =0;
				}
				F[i] = K[i]/Math.pow(S[i],2)  -( S[i]+ a*E*Math.cos(bata)*theWeather.TWI[i].t - E*deltaL*Math.pow(Math.cos(bata),2)/l1);
				if((i==0 || i==2 || i==4 || i==5 )&&F[i]>Fmax)
				{
					ctrl = i;
					Fmax = F[i];
					ctrlK  = K[i];
				}
			}

			let f0 = -99999;
			for(let i =0;i<10;i++)
			{
				T = theWeather.TWI[i].t;
				aa = Fmax +a*E*Math.cos(bata)*T;
				S[i] =0;
				f[i] =0;
				if(theWeather.TWI[i].b>0)
					G = Math.sqrt((m_weights*g)*(m_weights*g),(m_area*Math.pow(theWeather.TWI[i].v*Kh,2)/1.600)*(m_area*Math.pow(theWeather.TWI[i].v*Kh,2)/1.600))/n;
				else
					G = Math.sqrt((m_weight* g)*(m_weight* g),(m_area*Math.pow(theWeather.TWI[i].v*Kh,2)/1.600)*(m_area*Math.pow(theWeather.TWI[i].v*Kh,2)/1.600))/n;
				rs = G/A/m_length;
				r = GetLoad(i,7)/A;
				if(i==ctrl)
				{
					if(i ==0)
						S[i] = m_Tav/A;
					else if(i ==5)
						S[i] = m_Ttract/A;
					else
						S[i] = m_Tmax/A;
				}
				else
				{
					S[i] = GetEquationValue(1.0,aa,0,-K[i],9999);
				}
				f[i] = ( r*m_l*m_l/8 + (rs-r)*cl0*cl0/2 ) / S[i]/Math.cos(bata);
				if(i!=9  && f[i]>f0)
				{
					k = r/2/S[i];
					constA = (rs-r)*cl0*cl0/2/S[i];
					f0 = f[i];
				}
				else if(i ==9)
				{
					kMaxT = r/2/S[i];
					constMaxT = (rs-r)*cl0*cl0/2/S[i];
				}
			}
		}
		window.ComputeK = function(l0,sita) {
			let k=0;
			let condition = -1;
			k = GetMaxK(l0, sita,condition);
			return k;
		}
		window.ComputeK2 = function() {
			for (let i = m_start; i < m_end; i++) {
				initializeDataBool(towerlist[i].Distance,towerlist[i].u,true,1);
				if (towerlist[i].bInsular){
					let k,constant,kMaxT,constMaxT;
					ComputeIsolate(towerlist[i],towerlist[i+1],k,constant,kMaxT,constMaxT);
					towerlist[i].kPline = k;
					towerlist[i].kWind  = k;
					towerlist[i].kMaxT  = kMaxT;
					towerlist[i].constant = constant;
					towerlist[i].constMaxT = constMaxT;
				}else {
					towerlist[i].kPline = ComputeK(towerlist[i].Lk,towerlist[i].cosa);
					towerlist[i].kWind = GetLoad(3,7)/theLine.A/GetStrain(towerlist[i].Lk,towerlist[i].cosa,3)/2.0;
					towerlist[i].kMaxT = GetLoad(9,7)/theLine.A/GetStrain(towerlist[i].Lk,towerlist[i].cosa,9)/2.0;
				}
			}
		}
		window.GetLoaLob = function(l0,cosa,condition,l,h,Loa,Lob) {
			let s, p,r;
			s = GetStrain(l0,  cosa,condition);
			p = theWeather.TWI[condition].P7;//r为综合比载
			r = p/theLine.A;
			Loa = l/2.0 - s/r*arcsh(r*h/(2*s*sinh(r*l/2.0/s)));
			//Lob = l/2.0 + s/r*arcsh(r*h/(2*s*sinh(r*l/2.0/s)));
			Lob = l - Loa;
		}
		window.GetLoaLob2 = function(k,l,h) {
			let Loa = l/2.0 - arcsh(k*h/sinh(k*l))/2.0/k;
			let Lob = l - Loa;
			let lo = new Array(Loa,Lob);
			return lo

		}
		window.ComputeLH = function() {
			let sita;
			let indexComputeLH = -1;
			let count = towerlist.length;
			if (count > 0){
				towerlist[0].Lh1 = 0;
				towerlist[count-1].Lh2 = 0;
				for(let i=m_start;i<m_end;i++)
				{
					//计算单侧水平档距
					sita = Math.atan((towerlist[i+1].hugeHigh-towerlist[i].hugeHigh)/(towerlist[i+1].Distance - towerlist[i].Distance));
					towerlist[i].Lh2 = (towerlist[i+1].Distance - towerlist[i].Distance)/Math.cos(sita)/2;
					towerlist[i+1].Lh1 = (towerlist[i+1].Distance - towerlist[i].Distance)/Math.cos(sita)/2;
				}
				for(let i=m_start;i<=m_end;i++)
				{
					towerlist[i].Lh = towerlist[i].Lh1 + towerlist[i].Lh2;
					indexComputeLH = FindTower(towerlist[i]);
					if(indexComputeLH>0)
					{
						if(prk.TOWER[indexComputeLH].LH<towerlist[i].Lh)
							towerlist[i].towererror = true;
						else
							towerlist[i].towererror = false;
					}
				}
			}

		}
		window.ComputeLV = function(condition) {
			let Loa,Lob;
			let Lo = [];
			let indexComputeLV= -1;
			let k=0;
			let count = towerlist.length;
			if (count > 0) {
				towerlist[0].Lv1 = 0;
				towerlist[count-1].Lv2 = 0;
				for(let i=m_start;i<m_end;i++)
				{
					//计算单侧垂直档距
					if(condition<0)
						k = towerlist[i].kPline;
					else
					{
						initializeDataBool(towerlist[i].Distance,towerlist[i].u,true,1);
						k = GetLoad(condition,7)/theLine.A/GetStrain(towerlist[i].Lk,towerlist[i].cosa,condition)/2.0;
					}
					Lo = GetLoaLob2(k, (towerlist[i+1].Distance - towerlist[i].Distance), towerlist[i+1].hugeHigh-towerlist[i].hugeHigh)
					Loa = Lo[0];
					Lob = Lo[1];
					towerlist[i].Lv2 = Loa;
					towerlist[i+1].Lv1 = Lob;
				}
				for(let i=m_start;i<=m_end;i++)
				{
					if(condition<0)
					{
						towerlist[i].Lv = towerlist[i].Lv1 + towerlist[i].Lv2;
						indexComputeLV = FindTower(towerlist[i]);
						if(indexComputeLV>0)
						{
							if(prk.TOWER[indexComputeLV].LV<towerlist[i].Lv)
								towerlist[i].towererror = true;
							else
								towerlist[i].towererror = false;
						}
					}
					else if(condition == 1)
						towerlist[i].lvMaxTemp = towerlist[i].Lv1 + towerlist[i].Lv2;
					else if(condition == 2)
						towerlist[i].lvMinTemp = towerlist[i].Lv1 + towerlist[i].Lv2;
					else if(condition == 3)
						towerlist[i].lvMaxWind = towerlist[i].Lv1 + towerlist[i].Lv2;
					else if(condition == 4)
						towerlist[i].lvMaxIce  = towerlist[i].Lv1 + towerlist[i].Lv2;
				}
			}
		}
		window.ComputeLhLv = function() {
			ComputeLH();
			ComputeLV(-1);
		}
		window.ComputeGK = function(l0,cosa) {
			let k= 0;
			let condition = -1;
			k = GetMinK(l0, cosa,condition);
			return k;
		}
		window.ComputeGK2 = function() {
			for(let i=m_start;i<m_end;i++)
			{
				initializeDataBool(towerlist[i].Distance,1,false,1);
				towerlist[i].kGround = ComputeGK(towerlist[i].Lk,1);
			}
		}
		//最低点三角
		function DisplayFawLowest(x,y,x0,material) {
			// material = new THREE.LineBasicMaterial( { color: 0x000000 } );
			// let trianH = 0.5 * Math.tan(50 * (Math.PI/180));
			// console.log("三角形")
			// console.log(trianH);
			// let leftP = new THREE.Vector3(x/10+0.5-0.5,y - yMin + trianH,0);
			// let rightP = new THREE.Vector3(x/10+0.5+0.5,y - yMin + trianH,0);
			// let bottomP = new THREE.Vector3(x/10+0.5,y - yMin,0);
			// let triangleGeo = new THREE.Geometry();
			// triangleGeo.vertices.push(bottomP);
			// triangleGeo.vertices.push(leftP);
			// triangleGeo.vertices.push(rightP);
			// triangleGeo.vertices.push(bottomP);
			//
			// let triangle =new THREE.Line(triangleGeo,material);
			// scene.add(triangle);
		}
		//弧垂
	window.DisplayFawCurve = function(x1,y1,x2,y2,k,x0,bInsular,constt,length,material, name) {

			if (x1 < 0) return;
			let f,l1,l2,l,x3, y3;
			let loa,h;
			let endL,startL;
			let ptCount =0;
			let insertPoint = [];

			l1 = 0;
			l = x2-x1;
			h = y2-y1;
			loa = l/2.0 - arcsh(k*h/sinh(k*l))/2.0/k;
			if(!bInsular)
			{
				startL=x1;
				endL = Math.min(x2,xMax);
				ptCount = parseInt(endL - startL)+1;
				for(let i=0;i<ptCount &&i< 2048 ;i++ )
				{
					l1 = 1.0*i + startL-x1;
					l2 = l - l1;
					if(i!=ptCount-1)//非最后点
					{
						//P180手册公式
						f = l1*h/l +( sinh(k*(2*loa-l1)) * sinh(k*l1) )/k;
						x3 = x1 + l1;
						y3 = (l1*y2+l2*y1)/l-f;
						//y3 = y1-sinh(k*l2-arcsh(k*(y2-y1))/sinh(k*l)) * sinh(k*l1) /k;
					}
					else if(x2 <= xMax)	//最后一点
					{
						x3 = x2;
						y3 = y2;
					}
					insertPoint.push(new THREE.Vector3((x3-xMin)/xdivision*Gridsize, (y3 - yMin)/ydivision*Gridsize, 0))
				}
			}
			else
			{
				startL=x1;
				endL = Math.min( x2-length*Math.cos(Math.atan(h/l)),xMax );
				ptCount = parseInt (endL - startL)+2;
				for(let i=0;i<ptCount;i++ )
				{
					if(i==0)			//第一点
					{
						x3 = x1;
						y3 = y1;
					}
					else if(i!=ptCount-1)//中间点
					{
						l1 = 1.0*(i-1) + startL-x1;
						l2 = l - l1;
						//P193手册公式
						f =( k*l1*(l-l1) + constt )/Math.cos(Math.atan(h/l));
						x3 = x1 + l1;
						y3 = (l1*y2+l2*y1)/l-f;
					}
					else if(x2<=xMax)	//最后一点
					{
						x3 = x2;
						y3 = y2;
					}
					insertPoint.push(new THREE.Vector3((x3-xMin)/xdivision*Gridsize, (y3 - yMin)/ydivision*Gridsize, 0))
				}
			}
			// var conductMaterial = new THREE.LineBasicMaterial( { color: 0xff00ff } );
			var conductGeo = new THREE.Geometry();
			for (let i = 0 ; i <insertPoint.length ; i++){
				conductGeo.vertices.push(insertPoint[i]);
			}
			var conductObj = new THREE.Line( conductGeo, material );
			conductObj.name = name;
			conductObj.renderOrder = 999;
			conductObj.onBeforeRender = function( renderer ) { renderer.clearDepth(); };
			return conductObj;
		}
	window.DisplayFawCurve2 = function(x1,y1,x2,y2,k,dspLwst,bInsular,constt,length,material, name) {
			if( x2-x1<10 || x2-x1>3000 || Math.abs(y1-y2)>2000 ) {
				return;
			}
			let f,l1,l2,l;
			let loa,h,xx,yy;
			// let insertPoint = [];
			let lx1 = x1,lx2 = x2;
			l1 = 0;
			l = x2-x1;
			h = y2-y1;
			xx = (x1+x2)/2;
			if(k==0) k = 300*1E-6;
			//计算弧垂最低点坐标
			loa = l/2.0 - arcsh(k*h/sinh(k*l))/2.0/k;
			f = loa*h/l +( sinh(k*(2*loa-loa)) * sinh(k*loa) )/k;
			l = x2 - x1;
			l1 = loa;
			l2 = l-loa;
			xx = x1 + loa;
			yy = (l1*y2+l2*y1)/l-f;

			// if (dspLwst)
			//DisplayFawLowest(xx,  yy-constt, lx1, material);
			var Curve2res  = DisplayFawCurve( x1, y1, x2, y2, k, lx1, bInsular, constt,length,material, name);

			return Curve2res;

			//显示超出范围的弧垂
			// if((xx<x1 || xx>x2) && dspLwst)
			// {
			// 	if(xx<x1)
			// 	{
			// 		x2 = x1;
			// 		y2 = y1;
			// 		x1 = xx;
			// 		y1 = yy;
			// 	}
			// 	else
			// 	{
			// 		x1 = x2;
			// 		y1 = y2;
			// 		x2 = yy;
			// 		y2 = yy;
			// 	}
			// 	DisplayFawCurve(x1, y1, x2, y2, k, lx1, bInsular, constt,length,material, name);
			// }
		}
	window.DisplayFawCurve3 = function(tower1, tower2, kPower, kGround, name){
			let constt=0;
			var conductobj=Array();
			if(tower1.displayKType==0)
				constt = tower1.constant;
			else if(tower1.displayKType==1)
				constt = tower1.constMaxT;
			if(tower1.displayGround){
				let wire_material = new THREE.LineBasicMaterial({color: 0x000000});
				var conduct1 = DisplayFawCurve2(tower1.Distance,tower1.hugeGround,tower2.Distance,tower2.hugeGround,kGround,false,
						false,0,0,wire_material, name+"1");
			}
			if(tower1.displayPower){
				let wire_material1 = new THREE.LineBasicMaterial({color: 0x000000});
				var conduct2 = DisplayFawCurve2(tower1.Distance,tower1.hugeHigh, tower2.Distance,tower2.hugeHigh,kPower,true,
						tower1.bInsular,constt,tower1.InsulatorLength,wire_material1, name+"2");
			}
			if(tower1.displaySafe){
				let wire_material2 = new THREE.LineBasicMaterial({color: 0x0000ff});
				var conduct3 = DisplayFawCurve2(tower1.Distance,tower1.hugeHigh-tower1.LandDist, tower2.Distance,tower2.hugeHigh-tower1.LandDist,
						kPower,false,tower1.bInsular,constt,tower1.InsulatorLength,wire_material2, name+"3");
			}
			if(tower1.displayCross){
				let wire_material3 = new THREE.LineBasicMaterial({color: 0xff0000});
				var conduct4 = DisplayFawCurve2(tower1.Distance,tower1.hugeHigh-tower1.ElecDist, tower2.Distance,tower2.hugeHigh-tower1.ElecDist,
						kPower,false,tower1.bInsular,constt,tower1.InsulatorLength,wire_material3, name+"4");
			}
			//conductobj.push(conduct1);
			conductobj.push(conduct2);
			conductobj.push(conduct3);
			conductobj.push(conduct4);

			return conductobj;
		}
	window.DisplayFawCurve4 = function(tower1,tower2, name){
			var ConductCurve;
			if(tower1.displayKType==0){
				ConductCurve = DisplayFawCurve3(tower1, tower2, tower1.kPline, tower1.kGround, name);
			}
			// else if(tower1.displayKType==1)
			// 	DisplayFawCurve3(tower1, tower2, tower1.kMaxT,  tower1.kGround);

			return ConductCurve;

		}




	/* 创建杆塔函数 */
	var towerLineWid = 0.5;
	window.tower1 = function(towerHei) {  //4.5 InsulateLength
			let scale = 1 / ydivision * Gridsize;
			let tower = new THREE.Shape();
			tower.moveTo(-0.5,0);
			tower.lineTo(0.5,0);tower.lineTo(0.5,towerLineWid);tower.lineTo(0.25,towerLineWid);
			tower.lineTo(0.25,towerHei-4.5-towerLineWid);tower.lineTo(1,towerHei-4.5-towerLineWid);
			tower.lineTo(1,towerHei-4.5);tower.lineTo(0.25,towerHei-4.5);tower.lineTo(0.25,towerHei);
			tower.lineTo(-0.25,towerHei);tower.lineTo(-0.25,towerHei-4.5);tower.lineTo(-1,towerHei-4.5);
			tower.lineTo(-1,towerHei-4.5-towerLineWid);tower.lineTo(-0.25,towerHei-4.5-towerLineWid);
			tower.lineTo(-0.25,towerLineWid);tower.lineTo(-0.5,towerLineWid);
			tower.lineTo(-0.5,0);
			let towerGroup = new THREE.ShapeGeometry(tower);
			towerGroup.scale(scale,scale,scale);
			let towMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.DoubleSide } );
			var towMesh = new THREE.Mesh( towerGroup, towMaterial ) ;
			towMesh.renderOrder = towerHei;
			return towMesh;

			//draw line group
		}
	window.tower2 = function(towerHei) {
		let scale = 1 / ydivision * Gridsize;
		let tower = new THREE.Shape();
		tower.moveTo(-0.5,0);
		tower.lineTo(0.5,0);tower.lineTo(0.5,towerLineWid);tower.lineTo(0.25,towerLineWid);
		tower.lineTo(0.25,towerHei-towerLineWid*1.4);tower.lineTo(1,towerHei-towerLineWid*1.4-1);
		tower.lineTo(1,towerHei-towerLineWid*1.4);tower.lineTo(0,towerHei);tower.lineTo(-1,towerHei-towerLineWid*1.4);
		tower.lineTo(-1,towerHei-towerLineWid*1.4-1);tower.lineTo(-0.25,towerHei-towerLineWid*1.4);tower.lineTo(-0.25,towerLineWid);

		tower.lineTo(-0.5,towerLineWid);
		tower.lineTo(-0.5,0);
		let towerGroup = new THREE.ShapeGeometry(tower);
		towerGroup.scale(scale,scale,scale);
		let towMaterial = new THREE.MeshBasicMaterial( { color: 0x9400D3, side: THREE.DoubleSide } );
		var towMesh = new THREE.Mesh( towerGroup, towMaterial ) ;
		towMesh.renderOrder = towerHei;
		return towMesh;
	}


	window.createTower = function(pos,name,towTypeName,towType,towerHei,added){ //added true from draw false from tabledata push new or not
		if(towType!=0){var towMesh = tower2(towerHei);}
		else {var towMesh = tower1(towerHei);}
			towMesh.position.x = pos.x;
			towMesh.position.y = pos.y;
			towMesh.position.z = 0;
			towMesh.name = "fixTower";
			towMesh.geometry.name = name;
			if(added>-1){
				towerlist.splice(added,0,{
					"Name" : name,
					"Distance" : pos.x /Gridsize *xdivision+xMin,
					"High" : pos.y/Gridsize*ydivision + yMin,
					"Position":"",
					"offset":0,
					"TowerType" : towTypeName,
					"Base": 0,
					"TowerHigh" : towerHei,
					"Status" : towType,
					"InsulatorLength": 5.5,
					"ConnectLength": 0.0,
					"InsulateP": "",
					"InsulatePA": "X01",
					"InsulatePANum": -1,
					"InsulatePB": "X01",
					"InsulatePBNum": -1,
					"InsulatePC": "",
					"InsulatePCNum": 0,
					"hugeHigh":0,
					"hugeGround" : 0,		// 地线悬挂点高程
					"Lk": 0,
					"L": 0,
					"cosa":1,
					"bInsular":false,
					"constant": 0,
					"u": 1,
					"kPline": 0,			//导线大号侧k值系数
					"kGround": 0,		//地线大号侧K值系数
					"kWind": 0,			//大风条件前视档k值系数
					"kMaxT": 0,			//70度高温k值系数
					"constMaxT": 0,
					"Lh": 0,				// 水平档距
					"Lh1": 0,			// 小号侧垂直档距
					"Lh2": 0,			// 大号侧垂直档距
					"Lv" : 0,				// 垂直档距
					"Lv1" : 0,			// 小号侧水平档距
					"Lv2" : 0,			// 大号侧水平档距
					"lvMinTemp": 0,//最低气温垂直档距
					"lvMaxTemp": 0,//最高气温垂直档距
					"lvMaxIce": 0,//最大覆冰垂直档距
					"lvMaxWind": 0,//最大风垂直档距
					"displayKType": 0,	//k值类型，0为最大弧垂 1为最高线温
					"displayGround":0,		//显示地线
					"displayPower" : 1,		//显示导线
					"displaySafe" :  1,	//显示导线对地
					"displayCross" : 1,		//显示导线跨越
					"LandDist" : 8.5,		// 对地安全距离
					"ElecDist" : 6.0	// 电力线安全距离
				});
				m_start = 0;
				m_end = towerlist.length - 1;
				ComputeHugeHigh();
			}
			return towMesh;
		}

	function createTowerTemp(pos,towTypeName,towType){

			if(towType!=0){var towMesh = tower2(towerHei);}
			else {var towMesh = tower1(towerHei);}
			towMesh.position.x = pos.x;
			towMesh.position.y = pos.y;
			towMesh.position.z = 0;
			towMesh.name = "tower";



			towerlist.push({
				"Name" : "G",
				"Distance" : pos.x/Gridsize*xdivision+xMin,
				"High" :pos.y/Gridsize*ydivision + yMin,
				"Position":"",
				"offset":0,
				"TowerType" :  towTypeName,
				"Base": 0,
				"TowerHigh" : towerHei,
				"Status" : towType,
				"InsulatorLength": 5.5,
				"ConnectLength": 0.0,
				"InsulateP": "",
				"InsulatePA": "X01",
				"InsulatePANum": -1,
				"InsulatePB": "X01",
				"InsulatePBNum": -1,
				"InsulatePC": "",
				"InsulatePCNum": 0,
				"hugeHigh":0,
				"hugeGround" : 0,		// 地线悬挂点高程
				"Lk": 0,
				"L": 0,
				"cosa":1,
				"bInsular":false,
				"constant": 0,
				"u": 1,
				"kPline": 0,			//导线大号侧k值系数
				"kGround": 0,		//地线大号侧K值系数
				"kWind": 0,			//大风条件前视档k值系数
				"kMaxT": 0,			//70度高温k值系数
				"constMaxT": 0,
				"Lh": 0,				// 水平档距
				"Lh1": 0,			// 小号侧垂直档距
				"Lh2": 0,			// 大号侧垂直档距
				"Lv" : 0,				// 垂直档距
				"Lv1" : 0,			// 小号侧水平档距
				"Lv2" : 0,			// 大号侧水平档距
				"lvMinTemp": 0,//最低气温垂直档距
				"lvMaxTemp": 0,//最高气温垂直档距
				"lvMaxIce": 0,//最大覆冰垂直档距
				"lvMaxWind": 0,//最大风垂直档距
				"displayKType": 0,	//k值类型，0为最大弧垂 1为最高线温
				"displayGround":0,		//显示地线
				"displayPower" : 1,		//显示导线
				"displaySafe" :  1,	//显示导线对地
				"displayCross" : 1,		//显示导线跨越
				"LandDist" : 8.5,		// 对地安全距离
				"ElecDist" : 6.0	// 电力线安全距离
			});
			console.log("mousemove towerlist",towerlist);
			m_end = towerlist.length - 1;
			ComputeHugeHigh();

			scene.add(towMesh);
			var tempCurve;
			if (m_end > 0) {
				tempCurve = DisplayFawCurve4(towerlist[m_end - 1],towerlist[m_end], "move_wire");
				if(tempCurve[0]!=undefined){
					scene.add(tempCurve[0]);scene.add(tempCurve[1]);scene.add(tempCurve[2]);
				}
			}

			towerlist.pop();
			m_end = towerlist.length - 1;
			ComputeHugeHigh();
			console.log("mousemove towerlist pop",towerlist);
		}

	/* 获取射线与平面相交的交点 */
	var raycaster = new THREE.Raycaster();
	var mouse = new THREE.Vector2();

	window.getIntersects= function(event) {
		if(mainCanvas!=null) {
			mouse.x = ((event.clientX - mainCanvas.getBoundingClientRect().left) / mainCanvas.offsetWidth) * 2 - 1;
			mouse.y = -((event.clientY - mainCanvas.getBoundingClientRect().top) / mainCanvas.offsetHeight) * 2 + 1;

			var normal = new THREE.Vector3(0, 0, 1);
			var planeGround = new THREE.Plane(normal, 0);//创建平面

			raycaster.setFromCamera(mouse, camera);//从相机发出一条射线经过鼠标点击的位置
			var ray = raycaster.ray;//获取射线
			var intersects = new THREE.Vector3();
			intersects = ray.intersectPlane(planeGround, intersects);//计算相机到射线的对象，可能有多个对象，返回一个数组，按照距离相机远近排列
			return intersects;
		}
	}

	function getIntersectsObject(event) {
		var towerArr = [];
		var worldPoint  = getIntersects(event) ;
		//计算射线相机到的对象，可能有多个对象，因此返回的是一个数组，按离相机远近排列
		for (let i = 0; i < scene.children.length; i++) {
			if (scene.children[i].name === "fixTowerGroup"){
				towerArr = scene.children[i].children;
			}
		}
		for(let i=0;i<towerArr.length;i++){
			//Scalar adjust possibility
			var Box3= new THREE.Box3();
			if(Box3.expandByObject(towerArr[i]).expandByScalar(5).containsPoint(worldPoint)){
				return i;
			}
		}
		return -1;
	}

	var pointArray = [];
	var window_mouse = true;
	var intersects;
	var tempintersects;
	var putInd = 0;


		//放置杆塔
	function onMouseDown(event) {
		intersects = getIntersects(event);
		tempintersects = intersects;
		if (event.button == 0 ){
			if (!window_mouse){
				document.addEventListener("mousemove",onMouseMove,false);
				window_mouse = true;//避免事件重复添加
			}

			if (intersects.x<horSize &&intersects.x>0 && intersects.y<verSize && intersects.y>0){
				putInd = towerlist.length;
				console.log("clickdown",towerlist);
				var tempLine2Cor = [];
				for (let i = 0; i < m_linegroup.children.length; i++) {
					for(let j=0;j<m_linegroup.children[i].geometry.vertices.length;j++){
						tempLine2Cor.push([m_linegroup.children[i].geometry.vertices[j].x,m_linegroup.children[i].geometry.vertices[j].y]);
					}
				}
				var tempLine2 = turf.lineString(tempLine2Cor);
				var temppointLine1 = turf.lineString([[tempintersects.x,tempintersects.y+500],[tempintersects.x,0]]);  // +500? 4.8
				var interPoint1 = turf.lineIntersect(temppointLine1, tempLine2);
				tempintersects = new THREE.Vector3(tempintersects.x, interPoint1.features[0].geometry.coordinates[1], 0);
				//attach
				for(let i=0;i<pile_tabledata.length;i++){
					if(Math.abs(pile_tabledata[i].dist-xMin-intersects.x/Gridsize*xdivision)<20){
						intersects.x  = (pile_tabledata[i].dist-xMin)/xdivision*Gridsize;
						intersects.y  = (pile_tabledata[i].z-yMin)/ydivision*Gridsize;
						break;
					}
				}
///goto
				intersects.y+=20;

				var pointsGeometry = new THREE.Geometry();
				pointsGeometry.vertices.push(intersects);
				var temppointsGeometry = new THREE.Geometry();
				temppointsGeometry.vertices.push(tempintersects);

				var pointsMaterial = new THREE.PointsMaterial({color:0xff0000, size: 3});
				var points = new THREE.Points(pointsGeometry, pointsMaterial);
				var temppoints = new THREE.Points(temppointsGeometry, pointsMaterial);
				pointArray.push(temppoints);
				//putInd++;

				var pos = new THREE.Vector3(points.geometry.vertices[0].x,points.geometry.vertices[0].y,0);
				var tempLine1 = turf.lineString([[pos.x,pos.y],[pos.x,0]]);
				var interPoint = turf.lineIntersect(tempLine1, tempLine2);
				pos = new THREE.Vector3(points.geometry.vertices[0].x, interPoint.features[0].geometry.coordinates[1], 0);
				console.log("addtower",putInd,pos.x/Gridsize*xdivision,towerlist)
				if(putInd==0||pos.x/Gridsize*xdivision>towerlist[putInd-1].Distance){  //防止向前
					let towTypeName=layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").text();
					let towType =layer.getChildFrame('body',tpIndex).find("input[type='radio']:checked").val();
					console.log("beforetowmesh");console.log(scene.children.length);console.log(scene);
					var towmesh = createTower(pos,"G"+putInd,towTypeName,towType,towerHei,putInd);
					TowerGroup.add(towmesh);
					scene.add(TowerGroup);
					var tlabel = createSpritelabel(towerlist[m_end].Name,
							"Lh:"+towerlist[m_end].Lh.toFixed(0)+"/Lv:"+towerlist[m_end].Lv.toFixed(0)+
							"/Kv:"+(towerlist[m_end].Lv.toFixed(0)/towerlist[m_end].Lh.toFixed(0)).toFixed(2),
							towerlist[m_end].TowerType+"-"+towerlist[m_end].TowerHigh,
							"#000000",150,0,pos.x,pos.y+towerHei/ydivision*Gridsize+5,0)
					TowerScriptGroup.add(tlabel);
					scene.add(TowerScriptGroup);


					//draw line
					var CurveInsert;
					if (m_end >= 1) {
						CurveInsert=DisplayFawCurve4(towerlist[m_end - 1],towerlist[m_end], "fixwire");
					}
					FawCurveGroup.add(CurveInsert[0]);
					FawCurveGroup.add(CurveInsert[1]);
					FawCurveGroup.add(CurveInsert[2]);
					console.log("addtowmesh");console.log(scene.children.length);console.log(scene);
					scene.add(FawCurveGroup);
					//end draw
					let disToPile = []
					for (let i = 0; i < pile_tabledata.length; i++) {
						disToPile.push({
							"name": pile_tabledata[i].name,
							"dis": Math.abs(pile_tabledata[i].dist - pos.x /Gridsize*xdivision),
							"value": i
						})
					}
					disToPile.sort(compare("dis"));
					layer.getChildFrame('body',tpIndex).find("#pilelist").val(disToPile[0].value);

					var pileName= layer.getChildFrame('body',tpIndex).find("#pilelist").find("option[value="+ disToPile[0].value +"]").text();
					let gap;
					for (let i = 0; i < pile_tabledata.length; i++) {
						if (pile_tabledata[i].name == disToPile[0].name) {
							gap = pos.x /Gridsize*xdivision - pile_tabledata[i].dist;
						}
					}
					let gaptoPile = layer.getChildFrame('body',tpIndex).find("#gap")[0];
					console.log("gap pile", gap)
					gaptoPile.value = gap.toFixed(2);
					towerlist[towerlist.length-1].Position = pileName;
					towerlist[towerlist.length-1].offset = Number(gap.toFixed(0));

					towerlist[towerlist.length-1].TowerType = layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").text();

					//whj 3.7 refresh GridManager 获取的只有参数  需要发起ajax请求帮助计算填充表格
					console.log("set tower");
					console.log(towerlist);
					towerlist_tabledata=towerlist;
					GridManager.refreshGrid(towerlist_tableId);

					var inputId =  layer.getChildFrame('body',tpIndex).find("#towId")[0];
					inputId.value = "G" + putInd;
					// for (let i = m_end-1; i < m_end; i++) {
					// 	DisplayFawCurve4(towerlist[i], towerlist[i + 1], "fixwire");
					// }

				}
			}
		}
		if (event.button == 2){
			clearTempTow();
			putInd = 0;
			window_mouse = false;
			document.removeEventListener("mousemove",onMouseMove);
			document.removeEventListener("mousedown",onMouseDown);
			console.log("afterset",towerlist);
		}
	}

	function onMouseMove(event) {
		intersects = getIntersects(event);
		tempintersects = intersects;
		if(intersects!=undefined){
		if (intersects.x<horSize &&intersects.x>0 && intersects.y<verSize && intersects.y>0){
			clearTempTow();
			clearTempTow();
			var tempLine2Cor = [];

			for (let i = 0; i < m_linegroup.children.length; i++) {
				for(let j=0;j<m_linegroup.children[i].geometry.vertices.length;j++){
					tempLine2Cor.push([m_linegroup.children[i].geometry.vertices[j].x,m_linegroup.children[i].geometry.vertices[j].y]);
				}
			}
			var tempLine2 = turf.lineString(tempLine2Cor);
			//var temppointLine1 = turf.lineString([[tempintersects.x,tempintersects.y],[tempintersects.x,0]]);
			//var interPoint1 = turf.lineIntersect(temppointLine1, tempLine2);
			//tempintersects = new THREE.Vector3(intersects.x, interPoint1.features[0].geometry.coordinates[1], 0);
			//close to turning point setting attach
			for(let i=0;i<pile_tabledata.length;i++){
				if(Math.abs(pile_tabledata[i].dist-xMin-intersects.x/Gridsize*xdivision)<20){  //attach pilelist point 
					intersects.x  = (pile_tabledata[i].dist-xMin)/xdivision*Gridsize;
					//intersects.y  = (pile_tabledata[i].z-yMin)/ydivision*Gridsize;
					break;
				}
			}
///goto
			var pos = new THREE.Vector3(intersects.x, intersects.y, 0);
			var tempLine1 = turf.lineString([[pos.x,pos.y],[pos.x,0]]);
			var interPoint = turf.lineIntersect(tempLine1, tempLine2);
			let coorDif;
			if(interPoint.features[0]!=undefined){
				pos = new THREE.Vector3(intersects.x, interPoint.features[0].geometry.coordinates[1], 0);
				coorDif = intersects.y - interPoint.features[0].geometry.coordinates[1];
			}


			let towTypeName=layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").text();
			let towType =layer.getChildFrame('body',tpIndex).find("input[type='radio']:checked").val();  //towType  Status
			let towTypeIndex=layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").val();
			towerStartHei = prk.TOWER[towTypeIndex].StartHigh;
			towerEndHei = prk.TOWER[towTypeIndex].EndHigh;
			towerHeiDif = towerEndHei - towerStartHei;
			towerHeiInDif = prk.TOWER[towTypeIndex].Dhigh;
			towerHeiArray.length = towerHeiDif / towerHeiInDif + 1;
			for (let i = 0; i < towerHeiArray.length; i++) {
				towerHeiArray[i] = towerStartHei + i * towerHeiInDif;
			}
			towerHei = limit(towerHeiArray,coorDif);

			createTowerTemp(pos,towTypeName,towType);
			let disToPile = []
			for (let i = 0; i < pile_tabledata.length; i++) {
				disToPile.push({"name": pile_tabledata[i].name,
					"dis":Math.abs(pile_tabledata[i].dist - pos.x/Gridsize*xdivision),
					"value":i
				})
			}
			disToPile.sort(compare("dis"));
			layer.getChildFrame('body',tpIndex).find("#pilelist").val(disToPile[0].value);

			let gap;
			for (let i = 0; i < pile_tabledata.length; i++) {
				if (pile_tabledata[i].name == disToPile[0].name){
					gap = pos.x/Gridsize*xdivision - pile_tabledata[i].dist;
				}
			}
			let gaptoPile = layer.getChildFrame('body',tpIndex).find("#gap")[0];
			gaptoPile.value = gap.toFixed(2);
			var inputHei = layer.getChildFrame('body',tpIndex).find("#hei")[0];
			var inputDis = layer.getChildFrame('body',tpIndex).find("#dis")[0];

			let disNum = pos.x/Gridsize*xdivision + xMin;
			let heiNum = pos.y/Gridsize*ydivision + yMin;
			inputDis.value = disNum.toFixed(2);
			inputHei.value = heiNum.toFixed(2);

			var towerHigh = layer.getChildFrame('body',tpIndex).find("#towerheight")[0];
			for (let i = 0; i < towerHigh.length; i++) {
				if (Number(towerHigh[i].value) === towerHei){
					towerHigh[i].selected = true;
				}
			}
			var inputId =  layer.getChildFrame('body',tpIndex).find("#towId")[0];
			inputId.value = "G" + towerlist.length;
		}
		}
	}
	//清除动态排杆中的临时数据
	function clearTempTow(){
			if (scene.getObjectByName('move_wire1')) {
				scene.remove(scene.getObjectByName('move_wire1'));
			}
			if (scene.getObjectByName('move_wire2')) {
				scene.remove(scene.getObjectByName('move_wire2'));
			}
			if (scene.getObjectByName('move_wire3')) {
				scene.remove(scene.getObjectByName('move_wire3'));
			}
			if (scene.getObjectByName('move_wire4')) {
				scene.remove(scene.getObjectByName('move_wire4'));
			}
			if (scene.getObjectByName('tower')) {
				scene.remove(scene.getObjectByName('tower'));
			}
		}
	//保存排杆
	$("#saveTower").click(function () {
		var towerpwf = {"TOWERLIST":towerlist};
		savedJson.pwf = towerpwf;
		var pwfStr = JSON.stringify(towerpwf);
		var formData = new FormData();
		formData.append("pwf",pwfStr);
		formData.append("ProjectName", prjName);
		console.log(formData.get('pwf'));
		$.ajax({
			url: BASEURL+"/pwfsave", //提交的路径
			type: "post",       //提交方式
			data: formData,    //提交的数据
			// dataType:"json",
			contentType: false, // 告诉jQuery不要去设置Content-Type请求头
			processData: false,
			success: function (data) {
				console.log(data);
			},
			error: function (errorMsg) {
				alert(errorMsg);
			}
		});
	})

	//删除杆塔
	function towerDelete(event) {
			// document.body.style.cursor = "url(./css/cancel.ico) 9 9, default";
			if (event.button === 0){
				let deleteInd = getIntersectsObject(event);
				console.log("picked", deleteInd);
				// intersectsTower[0].object.material = new THREE.LineBasicMaterial({color: 0x00ffff});
				var msg = "删除杆塔"+towerlist[deleteInd].Name;

				if(deleteInd!=-1){
					if (confirm(msg) === true) {
						//let deleteInd = TowerGroup.children.findindexOf(intersectsTower[0].object.uuid);
						TowerGroup.remove(TowerGroup.children[deleteInd]);
						TowerScriptGroup.remove(TowerScriptGroup.children[deleteInd]);

						console.log(towerlist);


						console.log("deleteind", deleteInd)
						towerlist.splice(deleteInd,1);  //删去tower  towerlength -1
						m_end  = towerlist.length-1;
						ComputeHugeHigh();

						if(deleteInd!=0&&deleteInd<towerlist.length){ //judge delete head or end
							var changeCurve = DisplayFawCurve4(towerlist[deleteInd-1],towerlist[deleteInd],"fixwire");
							FawCurveGroup.children.splice((deleteInd-1)*3,6,changeCurve[0],changeCurve[1],changeCurve[2]);
							console.log("deleteCurve");console.log(changeCurve,FawCurveGroup);
						}
						else if(deleteInd==0){
							FawCurveGroup.children.splice(0,3);
						}
						else if(deleteInd==towerlist.length){
							FawCurveGroup.children.splice((deleteInd-1)*3,3);
						}
						towerlist_tabledata = towerlist;
						console.log(towerlist_tabledata);
						GridManager.setAjaxData(towerlist_tableId, {"data": towerlist_tabledata});
						GridManager.refreshGrid(towerlist_tableId);
					}
					else {
						return false;
					}
				}
				else{document.body.style.cursor = "default";
					document.removeEventListener("mousedown", towerDelete);}
				}

			if (event.button === 2){
				document.body.style.cursor = "default";
				document.removeEventListener("mousedown", towerDelete);
			}
		}
	//插入杆塔
	let tempTowerlist = Array; let insertReady = new Boolean(true) ;
	function TowerInsertMove(event){
		intersects = getIntersects(event);
		var insertInd;
		if(intersects!=undefined){
			clearTempTow();
			clearTempTow();
				var tempLine2Cor = [];

				for (let i = 0; i < m_linegroup.children.length; i++) {
					for(let j=0;j<m_linegroup.children[i].geometry.vertices.length;j++){
						tempLine2Cor.push([m_linegroup.children[i].geometry.vertices[j].x,m_linegroup.children[i].geometry.vertices[j].y]);
					}
				}
				var tempLine2 = turf.lineString(tempLine2Cor);
				//close to turning point setting attach
				for(let i=0;i<pile_tabledata.length;i++){
					if(Math.abs(pile_tabledata[i].dist-xMin-intersects.x/Gridsize*xdivision)<20){  //attach pilelist point
						intersects.x  = (pile_tabledata[i].dist-xMin)/xdivision*Gridsize;
						//intersects.y  = (pile_tabledata[i].z-yMin)/ydivision*Gridsize;
						break;
					}
				}
			//find thte index of the range
			for (let i = 0; i < ttowerlist.length - 1; i++) {
				if (intersects.x / Gridsize * xdivision + xMin- ttowerlist[i].Distance > 0 && intersects.x / Gridsize * xdivision + xMin - ttowerlist[i + 1].Distance < 0) {
					insertInd = i + 1;
					console.log("insertInd");
					console.log(insertInd);
					break;
				}
			}
///goto
				var pos = new THREE.Vector3(intersects.x, intersects.y, 0);
				var tempLine1 = turf.lineString([[pos.x,pos.y],[pos.x,0]]);
				var interPoint = turf.lineIntersect(tempLine1, tempLine2);
				let coorDif;
				if(interPoint.features[0]!=undefined){
					pos = new THREE.Vector3(intersects.x, interPoint.features[0].geometry.coordinates[1], 0);
					coorDif = intersects.y - interPoint.features[0].geometry.coordinates[1];
				}


				let towTypeName=layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").text();
				let towType =layer.getChildFrame('body',tpIndex).find("input[type='radio']:checked").val();  //towType  Status
				let towTypeIndex=layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").val();
				towerStartHei = prk.TOWER[towTypeIndex].StartHigh;
				towerEndHei = prk.TOWER[towTypeIndex].EndHigh;
				towerHeiDif = towerEndHei - towerStartHei;
				towerHeiInDif = prk.TOWER[towTypeIndex].Dhigh;
				towerHeiArray.length = towerHeiDif / towerHeiInDif + 1;
				for (let i = 0; i < towerHeiArray.length; i++) {
					towerHeiArray[i] = towerStartHei + i * towerHeiInDif;
				}
				towerHei = limit(towerHeiArray,coorDif);
			towerlist = [];//exchange towerlist and temptowerlist
			towerlist.push(ttowerlist[insertInd - 1]);
			towerlist.push({
				"Name": "G" + ttowerlist.length,
				"Distance": pos.x / Gridsize * xdivision + xMin,
				"High": pos.y / Gridsize * ydivision + yMin,
				"Position": "",
				"offset": 0,
				"TowerType": towTypeName,
				"Base": 0,
				"TowerHigh": towerHei,
				"Status": towType,
				"InsulatorLength": 5.5,
				"ConnectLength": 0.0,
				"InsulateP": "",
				"InsulatePA": "X01",
				"InsulatePANum": -1,
				"InsulatePB": "X01",
				"InsulatePBNum": -1,
				"InsulatePC": "",
				"InsulatePCNum": 0,
				"hugeHigh": 0,
				"hugeGround": 0,		// 地线悬挂点高程
				"Lk": 0,
				"L": 0,
				"cosa": 1,
				"bInsular": false,
				"constant": 0,
				"u": 1,
				"kPline": 0,			//导线大号侧k值系数
				"kGround": 0,		//地线大号侧K值系数
				"kWind": 0,			//大风条件前视档k值系数
				"kMaxT": 0,			//70度高温k值系数
				"constMaxT": 0,
				"Lh": 0,				// 水平档距
				"Lh1": 0,			// 小号侧垂直档距
				"Lh2": 0,			// 大号侧垂直档距
				"Lv": 0,				// 垂直档距
				"Lv1": 0,			// 小号侧水平档距
				"Lv2": 0,			// 大号侧水平档距
				"lvMinTemp": 0,//最低气温垂直档距
				"lvMaxTemp": 0,//最高气温垂直档距
				"lvMaxIce": 0,//最大覆冰垂直档距
				"lvMaxWind": 0,//最大风垂直档距
				"displayKType": 0,	//k值类型，0为最大弧垂 1为最高线温
				"displayGround": 0,		//显示地线
				"displayPower": 1,		//显示导线
				"displaySafe": 1,	//显示导线对地
				"displayCross": 1,		//显示导线跨越
				"LandDist": 8.5,		// 对地安全距离
				"ElecDist": 6.0	// 电力线安全距离
			});
			towerlist.push(ttowerlist[insertInd]);
			console.log("towerlist after insert", towerlist);
				// createTowerTemp(pos,towTypeName,towType);
				let disToPile = []
				for (let i = 0; i < pile_tabledata.length; i++) {
					disToPile.push({"name": pile_tabledata[i].name,
						"dis":Math.abs(pile_tabledata[i].dist - pos.x/Gridsize*xdivision),
						"value":i
					})
				}
				disToPile.sort(compare("dis"));
				layer.getChildFrame('body',tpIndex).find("#pilelist").val(disToPile[0].value);

				let gap;
				for (let i = 0; i < pile_tabledata.length; i++) {
					if (pile_tabledata[i].name == disToPile[0].name){
						gap = pos.x/Gridsize*xdivision - pile_tabledata[i].dist;
					}
				}
				let gaptoPile = layer.getChildFrame('body',tpIndex).find("#gap")[0];
				gaptoPile.value = gap.toFixed(2);
				var inputHei = layer.getChildFrame('body',tpIndex).find("#hei")[0];
				var inputDis = layer.getChildFrame('body',tpIndex).find("#dis")[0];

				let disNum = pos.x/Gridsize*xdivision + xMin;
				let heiNum = pos.y/Gridsize*ydivision + yMin;
				inputDis.value = disNum.toFixed(2);
				inputHei.value = heiNum.toFixed(2);

				var towerHigh = layer.getChildFrame('body',tpIndex).find("#towerheight")[0];
				for (let i = 0; i < towerHigh.length; i++) {
					if (Number(towerHigh[i].value) === towerHei){
						towerHigh[i].selected = true;
					}
				}
				var inputId =  layer.getChildFrame('body',tpIndex).find("#towId")[0];
				inputId.value = "G" + towerlist_tabledata.length;

				if (towerlist[1].Status != 0) {
					var towMesh = tower2(towerlist[1].TowerHigh);
				} else {
					var towMesh = tower1(towerlist[1].TowerHigh);
				}
				towMesh.position.x = pos.x;towMesh.position.y = pos.y;towMesh.position.z = 0;
				towMesh.name = "tower";
				scene.add(towMesh);
				m_end = towerlist.length-1;
				ComputeHugeHigh();

				for(let i = 0;i<m_end;i++){
					var  tempCurve = DisplayFawCurve4(towerlist[i],towerlist[i+1],"move_wire");
					scene.add(tempCurve[0]);scene.add(tempCurve[1]);scene.add(tempCurve[2]);
				}

				towerlist = ttowerlist;
			console.log("moveafterscene",scene,towerlist);
		}
	}
	function TowerInsertDown(event) {
//
		if (event.button === 0){
			if(insertReady) {
// 				console.log("insertReady",insertReady);
// 				intersects = getIntersects(event);
// 				tempTowerlist = towerlist;
// 				console.log("towerlist copy to temp");
// 				console.log(tempTowerlist);
//
// 				var tempLine2Cor = [];
//
// 				for (let i = 0; i < m_linegroup.children.length; i++) {
// 					for (let j = 0; j < m_linegroup.children[i].geometry.vertices.length; j++) {
// 						tempLine2Cor.push([m_linegroup.children[i].geometry.vertices[j].x, m_linegroup.children[i].geometry.vertices[j].y]);
// 					}
// 				}
// 				var tempLine2 = turf.lineString(tempLine2Cor);
// 				//find thte index of the range
// 				for (let i = 0; i < towerlist.length - 1; i++) {
// 					if (intersects.x / Gridsize * xdivision - towerlist[i].Distance > 0 && intersects.x / Gridsize * xdivision - towerlist[i + 1].Distance < 0) {
// 						insertInd = i + 1;
// 						break;
// 					}
// 				}
//
// ///goto
// 				var pos = new THREE.Vector3(intersects.x, intersects.y, 0);
// 				var tempLine1 = turf.lineString([[pos.x, pos.y], [pos.x, 0]]);
// 				var interPoint = turf.lineIntersect(tempLine1, tempLine2);
// 				let coorDif;
// 				if (interPoint.features[0] != undefined) {
// 					pos = new THREE.Vector3(intersects.x, interPoint.features[0].geometry.coordinates[1], 0);
// 					coorDif = intersects.y - interPoint.features[0].geometry.coordinates[1];
// 				}
//
//
// 				let towTypeName = layer.getChildFrame('body', tpIndex).find("#TowerType").find("option:selected").text();
// 				let towType = layer.getChildFrame('body', tpIndex).find("input[type='radio']:checked").val();  //towType  Status
// 				let towTypeIndex = layer.getChildFrame('body', tpIndex).find("#TowerType").find("option:selected").val();
// 				console.log(towTypeIndex);
// 				towerStartHei = prk.TOWER[towTypeIndex].StartHigh;
// 				towerEndHei = prk.TOWER[towTypeIndex].EndHigh;
// 				towerHeiDif = towerEndHei - towerStartHei;
// 				towerHeiInDif = prk.TOWER[towTypeIndex].Dhigh;
// 				towerHeiArray.length = towerHeiDif / towerHeiInDif + 1;
// 				for (let i = 0; i < towerHeiArray.length; i++) {
// 					towerHeiArray[i] = towerStartHei + i * towerHeiInDif;
// 				}
// 				towerHei = limit(towerHeiArray, coorDif);
//
// 				towerlist = [];//exchange towerlist and temptowerlist
// 				towerlist.push(tempTowerlist[insertInd - 1]);
// 				towerlist.push({
// 					"Name": "G" + tempTowerlist.length,
// 					"Distance": pos.x / Gridsize * xdivision + xMin,
// 					"High": pos.y / Gridsize * ydivision + yMin,
// 					"Position": "",
// 					"offset": 0,
// 					"TowerType": towTypeName,
// 					"Base": 0,
// 					"TowerHigh": towerHei,
// 					"Status": towType,
// 					"InsulatorLength": 5.5,
// 					"ConnectLength": 0.0,
// 					"InsulateP": "",
// 					"InsulatePA": "X01",
// 					"InsulatePANum": -1,
// 					"InsulatePB": "X01",
// 					"InsulatePBNum": -1,
// 					"InsulatePC": "",
// 					"InsulatePCNum": 0,
// 					"hugeHigh": 0,
// 					"hugeGround": 0,		// 地线悬挂点高程
// 					"Lk": 0,
// 					"L": 0,
// 					"cosa": 1,
// 					"bInsular": false,
// 					"constant": 0,
// 					"u": 1,
// 					"kPline": 0,			//导线大号侧k值系数
// 					"kGround": 0,		//地线大号侧K值系数
// 					"kWind": 0,			//大风条件前视档k值系数
// 					"kMaxT": 0,			//70度高温k值系数
// 					"constMaxT": 0,
// 					"Lh": 0,				// 水平档距
// 					"Lh1": 0,			// 小号侧垂直档距
// 					"Lh2": 0,			// 大号侧垂直档距
// 					"Lv": 0,				// 垂直档距
// 					"Lv1": 0,			// 小号侧水平档距
// 					"Lv2": 0,			// 大号侧水平档距
// 					"lvMinTemp": 0,//最低气温垂直档距
// 					"lvMaxTemp": 0,//最高气温垂直档距
// 					"lvMaxIce": 0,//最大覆冰垂直档距
// 					"lvMaxWind": 0,//最大风垂直档距
// 					"displayKType": 0,	//k值类型，0为最大弧垂 1为最高线温
// 					"displayGround": 0,		//显示地线
// 					"displayPower": 1,		//显示导线
// 					"displaySafe": 1,	//显示导线对地
// 					"displayCross": 1,		//显示导线跨越
// 					"LandDist": 8.5,		// 对地安全距离
// 					"ElecDist": 6.0	// 电力线安全距离
// 				});
// 				towerlist.push(tempTowerlist[insertInd]);
// 				console.log("towerlist after insert", towerlist);
//
// 				if (towerlist[1].Status != 0) {
// 					var towMesh = tower2(towerlist[1].TowerHigh);
// 				} else {
// 					var towMesh = tower1(towerlist[1].TowerHigh);
// 				}
// 				towMesh.position.x = pos.x;towMesh.position.y = pos.y;towMesh.position.z = 0;
// 				towMesh.name = "tower";
// 				scene.add(towMesh);
// 				m_end = towerlist.length-1;
// 				ComputeHugeHigh();
// 				for(let i = 0;i<m_end;i++){
// 					var  tempCurve = DisplayFawCurve4(towerlist[i],towerlist[i+1],"move_wire");
// 					scene.add(tempCurve[0]);scene.add(tempCurve[1]);scene.add(tempCurve[2]);
// 				}
// 				towerlist = towerlist_tabledata; // return to towerlist
				console.log("insertReady",towerlist,scene);
				document.addEventListener('mousemove', TowerInsertMove, false);
				insertReady = false;
				ttowerlist = towerlist;

			}
			else{
				console.log("insertReady",insertReady,towerlist,scene);
				insertReady = true;
				//add tower to list
				//var temptowerlist = towerlist[0];  //don't use global variable assignments
				var temptowerlist = {
					"Name":"",
					"Distance": 0,
					"High": 0,
					"Position": "",
					"offset": 0,
					"TowerType": "",
					"Base": 0,
					"TowerHigh": 0,
					"Status": 0,
					"InsulatorLength": 5.5,
					"ConnectLength": 0.0,
					"InsulateP": "",
					"InsulatePA": "X01",
					"InsulatePANum": -1,
					"InsulatePB": "X01",
					"InsulatePBNum": -1,
					"InsulatePC": "",
					"InsulatePCNum": 0,
					"hugeHigh": 0,
					"hugeGround": 0,		// 地线悬挂点高程
					"Lk": 0,
					"L": 0,
					"cosa": 1,
					"bInsular": false,
					"constant": 0,
					"u": 1,
					"kPline": 0,			//导线大号侧k值系数
					"kGround": 0,		//地线大号侧K值系数
					"kWind": 0,			//大风条件前视档k值系数
					"kMaxT": 0,			//70度高温k值系数
					"constMaxT": 0,
					"Lh": 0,				// 水平档距
					"Lh1": 0,			// 小号侧垂直档距
					"Lh2": 0,			// 大号侧垂直档距
					"Lv": 0,				// 垂直档距
					"Lv1": 0,			// 小号侧水平档距
					"Lv2": 0,			// 大号侧水平档距
					"lvMinTemp": 0,//最低气温垂直档距
					"lvMaxTemp": 0,//最高气温垂直档距
					"lvMaxIce": 0,//最大覆冰垂直档距
					"lvMaxWind": 0,//最大风垂直档距
					"displayKType": 0,	//k值类型，0为最大弧垂 1为最高线温
					"displayGround": 0,		//显示地线
					"displayPower": 1,		//显示导线
					"displaySafe": 1,	//显示导线对地
					"displayCross": 1,		//显示导线跨越
					"LandDist": 8.5,		// 对地安全距离
					"ElecDist": 6.0	// 电力线安全距离
				};
				temptowerlist.Name = layer.getChildFrame('body',tpIndex).find("#towId")[0].value;
				temptowerlist.Distance = Number(layer.getChildFrame('body',tpIndex).find("#dis")[0].value);
				temptowerlist.High = Number(layer.getChildFrame('body',tpIndex).find("#hei")[0].value);
				temptowerlist.offset = Number(layer.getChildFrame('body',tpIndex).find("#gap")[0].value);
				temptowerlist.TowerType = layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").text();
				temptowerlist.Status = Number(layer.getChildFrame('body',tpIndex).find("input[type='radio']:checked").val());
				temptowerlist.TowerHigh = Number(layer.getChildFrame('body',tpIndex).find("#towerheight").find("option:selected").val());
				console.log(temptowerlist,temptowerlist.Distance);
				var tpos={};
				tpos.x = (temptowerlist.Distance-xMin)/xdivision*Gridsize;
				tpos.y = (temptowerlist.High - yMin)/ydivision*Gridsize;
				tpos.z = 0;
				//InsertInd;
				var insertInd;
				for (let i = 0; i < ttowerlist.length - 1; i++) {
					if ((temptowerlist.Distance - ttowerlist[i].Distance) > 0 && (temptowerlist.Distance - ttowerlist[i + 1].Distance )< 0) {
						insertInd = i + 1;
						break;
					}
				}
				//change towerstyle and towerscript
				console.log("insertInd",insertInd);
				var towMesh=createTower(tpos,
						temptowerlist.Name,
						temptowerlist.TowerType,
						temptowerlist.Status,
						temptowerlist.TowerHigh,
						insertInd  
				);
				TowerGroup.children.splice(insertInd,0,towMesh);
				towerlist[insertInd].offset =  temptowerlist.offset;
				towerlist[insertInd].Position = layer.getChildFrame('body',tpIndex).find("#pilelist").find("option:selected")[0].innerHTML;


				console.log("InsertAdd",towerlist);
				ComputeHugeHigh();
				var insertlabel = createSpritelabel(towerlist[insertInd].Name,
						"Lh:"+towerlist[insertInd].Lh.toFixed(0)+"/Lv:"+towerlist[insertInd].Lv.toFixed(0)+
						"/Kv:"+(towerlist[insertInd].Lv.toFixed(0)/towerlist[insertInd].Lh.toFixed(0)).toFixed(2),
						towerlist[insertInd].TowerType+"-"+towerlist[insertInd].TowerHigh,
						"#000000",150,0,tpos.x,tpos.y+towerlist[insertInd].TowerHigh/ydivision*Gridsize+5,0);

				TowerScriptGroup.children.splice(insertInd,0,insertlabel);

				//scene fixtower fixwire add
				if(insertInd!=0&&insertInd<towerlist.length){ //judge delete head or end
					var leftCurve = DisplayFawCurve4(towerlist[insertInd-1],towerlist[insertInd],"fixwire");
					var rightCurve = DisplayFawCurve4(towerlist[insertInd],towerlist[insertInd+1],"fixwire");
					FawCurveGroup.children.splice((insertInd-1)*3,3,leftCurve[0],leftCurve[1],leftCurve[2]);
					FawCurveGroup.children.splice((insertInd)*3,0,rightCurve[0],rightCurve[1],rightCurve[2]);
				}
				else if(insertInd==0){
					FawCurveGroup.children.splice(0,3);
				}
				else if(insertInd==towerlist.length){
					FawCurveGroup.children.splice((insertInd-1)*3,3);
				}
				
				console.log("Insertafter");
				console.log(scene,towerlist);

				document.removeEventListener("mousemove",TowerInsertMove);
			}
				// let currentTow = [];
				// let deleteWire = [];
				// intersects = getIntersects(event);
				// tempintersects = intersects;
				//
				//
				//
				// var tempLine2Cor = [];
				// for (let i = 0; i < m_linegroup.children.length; i++) {
				// 	for(let j=0;j<m_linegroup.children[i].geometry.vertices.length;j++){
				// 		tempLine2Cor.push([m_linegroup.children[i].geometry.vertices[j].x,m_linegroup.children[i].geometry.vertices[j].y]);
				// 	}
				// }
				// var tempLine2 = turf.lineString(tempLine2Cor);
				// var temppointLine1 = turf.lineString([[tempintersects.x,tempintersects.y+500],[tempintersects.x,0]]); // m_line intersect point
				// var interPoint1 = turf.lineIntersect(temppointLine1, tempLine2);
				// tempintersects = new THREE.Vector3(tempintersects.x, interPoint1.features[0].geometry.coordinates[1], 0);
				//
				// var pointsGeometry = new THREE.Geometry();
				// pointsGeometry.vertices.push(intersects);
				// var temppointsGeometry = new THREE.Geometry();
				// temppointsGeometry.vertices.push(tempintersects);
				//
				// var pointsMaterial = new THREE.PointsMaterial({color:0xff0000, size: 3});
				// var points = new THREE.Points(pointsGeometry, pointsMaterial);
				// var temppoints = new THREE.Points(temppointsGeometry, pointsMaterial);
				// pointArray.push(temppoints);
				// putInd++;
				//
				// var pos = new THREE.Vector3(points.geometry.vertices[0].x,points.geometry.vertices[0].y,0);
				// var tempLine1 = turf.lineString([[pos.x,pos.y],[pos.x,0]]);
				// var interPoint = turf.lineIntersect(tempLine1, tempLine2);
				// pos = new THREE.Vector3(points.geometry.vertices[0].x, interPoint.features[0].geometry.coordinates[1], 0);
				//
				// let towTypeName=layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").text();
				// let towType =layer.getChildFrame('body',tpIndex).find("input[type='radio']:checked").val();
				// console.log("beforetowmesh");console.log(scene.children.length);console.log(scene);
				// //var towmesh = createTower(pos,"G"+putInd,towTypeName,towType,towerHei,);
				//
				// for (let i = 0; i < scene.children.length; i++) {
				// 	if (scene.children[i].name === "fixwire1" || scene.children[i].name === "fixwire2" || scene.children[i].name === "fixwire3" || scene.children[i].name === "fixwire4") {
				// 		deleteWire.push(scene.children[i]);
				// 	}
				// }
				// for(let i = 0; i < deleteWire.length; i++){
				// 	scene.remove(deleteWire[i]);
				// }
				//
				// scene.children.sort(compare('position'))
				// /****修改****/
				// towerlist = []
				// for (let i = 0; i < scene.children.length; i++) {
				// 	if (scene.children[i].name == "fixTower") {
				// 		currentTow.push({
				// 			"posX":scene.children[i].position.x,
				// 			"object":scene.children[i]
				// 		});
				// 		towerlist.push({
				// 			"Name": "G" + i,
				// 			"Distance": scene.children[i].position.x / Gridsize * xdivision + xMin,
				// 			"High": scene.children[i].position.y / Gridsize * ydivision + yMin,
				// 			"TowerType": "ZMVA41",
				// 			"Base": 0,
				// 			"TowerHigh": scene.children[i].geometry.vertices[7].y / (1 / ydivision * Gridsize),
				// 			"Status": 0,
				// 			"InsulatorLength": 5.5,
				// 			"ConnectLength": 0.0,
				// 			"InsulateP": "",
				// 			"InsulatePA": "X01",
				// 			"InsulatePANum": -1,
				// 			"InsulatePB": "X01",
				// 			"InsulatePBNum": -1,
				// 			"InsulatePC": "",
				// 			"InsulatePCNum": 0,
				// 			"hugeHigh": 0,
				// 			"hugeGround": 0,		// 地线悬挂点高程
				// 			"Lk": 0,
				// 			"L": 0,
				// 			"cosa": 1,
				// 			"bInsular": false,
				// 			"constant": 0,
				// 			"u": 1,
				// 			"kPline": 0,			//导线大号侧k值系数
				// 			"kGround": 0,		//地线大号侧K值系数
				// 			"kWind": 0,			//大风条件前视档k值系数
				// 			"kMaxT": 0,			//70度高温k值系数
				// 			"constMaxT": 0,
				// 			"Lh": 0,				// 水平档距
				// 			"Lh1": 0,			// 小号侧垂直档距
				// 			"Lh2": 0,			// 大号侧垂直档距
				// 			"Lv": 0,				// 垂直档距
				// 			"Lv1": 0,			// 小号侧水平档距
				// 			"Lv2": 0,			// 大号侧水平档距
				// 			"lvMinTemp": 0,//最低气温垂直档距
				// 			"lvMaxTemp": 0,//最高气温垂直档距
				// 			"lvMaxIce": 0,//最大覆冰垂直档距
				// 			"lvMaxWind": 0,//最大风垂直档距
				// 			"displayKType": 0,	//k值类型，0为最大弧垂 1为最高线温
				// 			"displayGround": 0,		//显示地线
				// 			"displayPower": 1,		//显示导线
				// 			"displaySafe": 1,	//显示导线对地
				// 			"displayCross": 1,		//显示导线跨越
				// 			"LandDist": 8.5,		// 对地安全距离
				// 			"ElecDist": 6.0	// 电力线安全距离
				// 		})
				// 	}
				// }
				// /****修改****/
				// currentTow.sort(compare('posX'))
				// for (let j = 0; j < currentTow.length; j++) {
				// 	for (let i = 0; i < scene.children.length; i++) {
				// 		if (scene.children[i].uuid == currentTow[j].object.uuid){
				// 			scene.children[i].geometry.name = "G" + j;
				// 		}
				// 	}
				// }
				//
				// let disToPile = []
				// for (let i = 0; i < pile_tabledata.length; i++) {
				// 	disToPile.push({"name": pile_tabledata[i].name,
				// 		"dis":Math.abs(pile_tabledata[i].dist - pos.x/Gridsize*xdivision),
				// 		"value":i
				// 	})
				// }
				// disToPile.sort(compare("dis"));
				// layer.getChildFrame('body',tpIndex).find("#pilelist").val(disToPile[0].value);
				// let gap;
				// for (let i = 0; i < pile_tabledata.length; i++) {
				// 	if (pile_tabledata[i].name == disToPile[0].name){
				// 		gap = pos.x/Gridsize*xdivision - pile_tabledata[i].dist;
				// 	}
				// }
				// let gaptoPile = layer.getChildFrame('body',tpIndex).find("#gap")[0];
				// gaptoPile.value = gap.toFixed(2);
				// var inputHei = layer.getChildFrame('body',tpIndex).find("#hei")[0];
				// var inputDis = layer.getChildFrame('body',tpIndex).find("#dis")[0];
				//
				// let disNum = pos.x/Gridsize*xdivision + xMin;
				// let heiNum = pos.y/Gridsize*ydivision + yMin;
				// inputDis.value = disNum.toFixed(2);
				// inputHei.value = heiNum.toFixed(2);
				//
				// var inputId =  layer.getChildFrame('body',tpIndex).find("#towId")[0];
				// inputId.value = "G" + towerlist.length;
				//
				// console.log("then",towerlist)
				// m_end = towerlist.length - 1;
				// /****修改****/
				// towerlist.sort(compare('Distance'));
				// ComputeHugeHigh();
				// /****修改****/
				// for (let i = 0; i < towerlist.length; i++) {
				// 	towerlist[i].Name = "G" + i;
				// }
				// for (let i = m_start; i < m_end; i++) {
				// 	DisplayFawCurve4(towerlist[i],towerlist[i+1], "fixwire");
				// }
				//
				// towerlist_tabledata=towerlist;
				// GridManager.setAjaxData(towerlist_tableId,{"data":towerlist_tabledata});
				// GridManager.refreshGrid(towerlist_tableId);
			}
			if (event.button === 2){
				clearTempTow();
				clearTempTow();

				scene.remove(scene.getObjectByName('tower'));
				document.removeEventListener("mousemove",TowerInsertMove);
				document.removeEventListener("mousedown",TowerInsertDown);
				console.log("rightbuttondown",scene);
			}
		}
	//移动杆塔
	let	movingReady  = new Boolean(true);
	function TowerMovingMove(event){
			intersects = getIntersects(event);
			console.log("movingInd",movingInd);
			if(intersects!=undefined){
				clearTempTow();
				clearTempTow();
				var tempLine2Cor = [];

				for (let i = 0; i < m_linegroup.children.length; i++) {
					for(let j=0;j<m_linegroup.children[i].geometry.vertices.length;j++){
						tempLine2Cor.push([m_linegroup.children[i].geometry.vertices[j].x,m_linegroup.children[i].geometry.vertices[j].y]);
					}
				}
				var tempLine2 = turf.lineString(tempLine2Cor);
				//close to turning point setting attach
				for(let i=0;i<pile_tabledata.length;i++){
					if(Math.abs(pile_tabledata[i].dist-xMin-intersects.x/Gridsize*xdivision)<20){  //attach pilelist point
						intersects.x  = (pile_tabledata[i].dist-xMin)/xdivision*Gridsize;
						//intersects.y  = (pile_tabledata[i].z-yMin)/ydivision*Gridsize;
						break;
					}
				}
				//find thte index of the range

///goto
				var pos = new THREE.Vector3(intersects.x, intersects.y, 0);
				var tempLine1 = turf.lineString([[pos.x,pos.y],[pos.x,0]]);
				var interPoint = turf.lineIntersect(tempLine1, tempLine2);
				let coorDif;
				if(interPoint.features[0]!=undefined){
					pos = new THREE.Vector3(intersects.x, interPoint.features[0].geometry.coordinates[1], 0);
					coorDif = intersects.y - interPoint.features[0].geometry.coordinates[1];
				}


				let towTypeName=layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").text();
				let towType =layer.getChildFrame('body',tpIndex).find("input[type='radio']:checked").val();  //towType  Status
				let towTypeIndex=layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").val();
				towerStartHei = prk.TOWER[towTypeIndex].StartHigh;
				towerEndHei = prk.TOWER[towTypeIndex].EndHigh;
				towerHeiDif = towerEndHei - towerStartHei;
				towerHeiInDif = prk.TOWER[towTypeIndex].Dhigh;
				towerHeiArray.length = towerHeiDif / towerHeiInDif + 1;
				for (let i = 0; i < towerHeiArray.length; i++) {
					towerHeiArray[i] = towerStartHei + i * towerHeiInDif;
				}
				towerHei = limit(towerHeiArray,coorDif);
				towerlist = [] ; //exchange ttowerlist towerlist
				if(movingInd>0){towerlist.push(ttowerlist[movingInd - 1])};
				towerlist.push({
					"Name": "G" + movingInd,
					"Distance": pos.x / Gridsize * xdivision + xMin,
					"High": pos.y / Gridsize * ydivision + yMin,
					"Position": "",
					"offset": 0,
					"TowerType": towTypeName,
					"Base": 0,
					"TowerHigh": towerHei,
					"Status": towType,
					"InsulatorLength": 5.5,
					"ConnectLength": 0.0,
					"InsulateP": "",
					"InsulatePA": "X01",
					"InsulatePANum": -1,
					"InsulatePB": "X01",
					"InsulatePBNum": -1,
					"InsulatePC": "",
					"InsulatePCNum": 0,
					"hugeHigh": 0,
					"hugeGround": 0,		// 地线悬挂点高程
					"Lk": 0,
					"L": 0,
					"cosa": 1,
					"bInsular": false,
					"constant": 0,
					"u": 1,
					"kPline": 0,			//导线大号侧k值系数
					"kGround": 0,		//地线大号侧K值系数
					"kWind": 0,			//大风条件前视档k值系数
					"kMaxT": 0,			//70度高温k值系数
					"constMaxT": 0,
					"Lh": 0,				// 水平档距
					"Lh1": 0,			// 小号侧垂直档距
					"Lh2": 0,			// 大号侧垂直档距
					"Lv": 0,				// 垂直档距
					"Lv1": 0,			// 小号侧水平档距
					"Lv2": 0,			// 大号侧水平档距
					"lvMinTemp": 0,//最低气温垂直档距
					"lvMaxTemp": 0,//最高气温垂直档距
					"lvMaxIce": 0,//最大覆冰垂直档距
					"lvMaxWind": 0,//最大风垂直档距
					"displayKType": 0,	//k值类型，0为最大弧垂 1为最高线温
					"displayGround": 0,		//显示地线
					"displayPower": 1,		//显示导线
					"displaySafe": 1,	//显示导线对地
					"displayCross": 1,		//显示导线跨越
					"LandDist": 8.5,		// 对地安全距离
					"ElecDist": 6.0	// 电力线安全距离
				});
				if(movingInd<ttowerlist.length-1){towerlist.push(ttowerlist[movingInd+1]);}
				console.log("towerlist after insert", towerlist);

				let disToPile = []
				for (let i = 0; i < pile_tabledata.length; i++) {
					disToPile.push({"name": pile_tabledata[i].name,
						"dis":Math.abs(pile_tabledata[i].dist - pos.x/Gridsize*xdivision),
						"value":i
					})
				}
				disToPile.sort(compare("dis"));
				layer.getChildFrame('body',tpIndex).find("#pilelist").val(disToPile[0].value);

				let gap;
				for (let i = 0; i < pile_tabledata.length; i++) {
					if (pile_tabledata[i].name == disToPile[0].name){
						gap = pos.x/Gridsize*xdivision - pile_tabledata[i].dist;
					}
				}
				let gaptoPile = layer.getChildFrame('body',tpIndex).find("#gap")[0];
				gaptoPile.value = gap.toFixed(2);
				var inputHei = layer.getChildFrame('body',tpIndex).find("#hei")[0];
				var inputDis = layer.getChildFrame('body',tpIndex).find("#dis")[0];

				let disNum = pos.x/Gridsize*xdivision + xMin;
				let heiNum = pos.y/Gridsize*ydivision + yMin;
				inputDis.value = disNum.toFixed(2);
				inputHei.value = heiNum.toFixed(2);

				var towerHigh = layer.getChildFrame('body',tpIndex).find("#towerheight")[0];
				for (let i = 0; i < towerHigh.length; i++) {
					if (Number(towerHigh[i].value) === towerHei){
						towerHigh[i].selected = true;
					}
				}
				if (towerlist[1].Status != 0) {
					var towMesh = tower2(towerHei);
				} else {
					var towMesh = tower1(towerHei);
				}
				towMesh.position.x = pos.x;towMesh.position.y = pos.y;towMesh.position.z = 0;
				towMesh.name = "tower";
				scene.add(towMesh);
				m_end = towerlist.length-1;
				ComputeHugeHigh();

				for(let i = 0;i<m_end;i++){
					var  tempCurve = DisplayFawCurve4(towerlist[i],towerlist[i+1],"move_wire");
					scene.add(tempCurve[0]);scene.add(tempCurve[1]);scene.add(tempCurve[2]);
				}

				towerlist = ttowerlist;
				console.log("moveafterscene ",scene,towerlist);


				console.log("Movingafter");
				console.log(scene,towerlist);

			}
		}
	function TowerMovingDown(event) {
			if (event.button === 0){
				if(movingReady) {
					movingInd = getIntersectsObject(event);
					console.log("movingReady",towerlist,scene,movingInd);
					layer.getChildFrame('body',tpIndex).find("#towId")[0].value=towerlist[movingInd].Name;
					layer.getChildFrame('body',tpIndex).find("#dis")[0].value=towerlist[movingInd].Distance.toFixed(2);
					layer.getChildFrame('body',tpIndex).find("#hei")[0].value=towerlist[movingInd].High.toFixed(2);
					layer.getChildFrame('body',tpIndex).find("#gap")[0].value=towerlist[movingInd].offset;
					console.log(layer.getChildFrame('body',tpIndex).find('input[type=radio][name = towType]'));
					let St=layer.getChildFrame('body',tpIndex).find('input[type=radio]');
					console.log("ST");console.log(St);
					if(towerlist[movingInd].Status==0){$(St[0]).prop('checked',true);}

					else if(towerlist[movingInd].Status==3){$(St[2]).prop('checked',true);}
					else{$(St[1]).prop('checked',true);}
					layer.getChildFrame('body',tpIndex).find("#TowerType").empty();
					if(prk.TOWER!=undefined){
						for (let i = 0; i < prk.TOWER.length; i++) { //DJCS omit
							if(prk.TOWER[i].type==towerlist[movingInd].Status){layer.getChildFrame('body',tpIndex).find("#TowerType").append("<option value='"+i+"'>"+prk.TOWER[i].Name+"</option>")};
						}
					}
					var selectindex = TowerPRKIndex(prk,towerlist[movingInd].TowerType);
					console.log("selectindex");console.log(selectindex);
					layer.getChildFrame('body',tpIndex).find("#towerheight").empty();
					for (let i = prk.TOWER[selectindex].StartHigh;i<=prk.TOWER[selectindex].EndHigh;i=i+prk.TOWER[selectindex].Dhigh){
						layer.getChildFrame('body',tpIndex).find("#towerheight").append("<option value='"+i+"'>"+i+"</option>");
					}
					console.log(layer.getChildFrame('body',tpIndex).find("#towerheight"));
					//console.log(layer.getChildFrame('body',tpIndex).find("#TowerType option[text='"+towerlist[movingInd].TowerType+"']"));
					layer.getChildFrame('body',tpIndex).find("#TowerType option:contains('"+towerlist[movingInd].TowerType+"')").attr("selected",true);
					layer.getChildFrame('body',tpIndex).find("#towerheight").val(towerlist[movingInd].TowerHigh);
					//bind select option setting
					layer.getChildFrame('body',tpIndex).find("#pilelist").empty();
					for (let i = 0; i < pile_tabledata.length; i++) {
						layer.getChildFrame('body',tpIndex).find("#pilelist").append("<option value='"+i+"'>"+pile_tabledata[i].name+"</option>");
					}
					layer.getChildFrame('body',tpIndex).find("#pilelist option:contains('"+towerlist[movingInd].Position+"')").attr("selected",true);
					movingReady = false;
					ttowerlist = towerlist;
					document.addEventListener('mousemove', TowerMovingMove, false);

				}
				else{
					console.log("movingReady",movingReady,towerlist,scene);
					movingReady = true;
					//add tower to list
					towerlist[movingInd].Name = layer.getChildFrame('body',tpIndex).find("#towId")[0].value;
					towerlist[movingInd].Distance = Number(layer.getChildFrame('body',tpIndex).find("#dis")[0].value);
					towerlist[movingInd].High = Number(layer.getChildFrame('body',tpIndex).find("#hei")[0].value);
					towerlist[movingInd].offset = Number(layer.getChildFrame('body',tpIndex).find("#gap")[0].value);
					towerlist[movingInd].TowerType = layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").text();
					towerlist[movingInd].Status = Number(layer.getChildFrame('body',tpIndex).find("input[type='radio']:checked").val());
					towerlist[movingInd].TowerHigh = Number(layer.getChildFrame('body',tpIndex).find("#towerheight").find("option:selected").val());
					console.log(towerlist[movingInd]);
					console.log("towerlist after moving", towerlist);
					var tpos = {};
					tpos.x = (towerlist[movingInd].Distance-xMin)/xdivision*Gridsize;
					tpos.y = (towerlist[movingInd].High-yMin)/ydivision*Gridsize;
					tpos.z = 0;
					TowerGroup.children[movingInd]= createTower(tpos,
							towerlist[movingInd].Name,
							towerlist[movingInd].TowerType,
							towerlist[movingInd].Status,
							towerHei,
							-1);
					m_end = towerlist.length-1;

					ComputeHugeHigh();
					TowerScriptGroup.children[movingInd] = createSpritelabel(towerlist[movingInd].Name,
							"Lh:"+towerlist[movingInd].Lh.toFixed(0)+"/Lv:"+towerlist[movingInd].Lv.toFixed(0)+
							"/Kv:"+(towerlist[movingInd].Lv.toFixed(0)/towerlist[movingInd].Lh.toFixed(0)).toFixed(2),
							towerlist[movingInd].TowerType+"-"+towerlist[movingInd].TowerHigh,
							"#000000",150,0,tpos.x,tpos.y+towerlist[movingInd].TowerHigh/ydivision*Gridsize+5,0);

					if(movingInd!=0&&movingInd<towerlist.length-1){ //judge delete head or end
						var leftCurve = DisplayFawCurve4(towerlist[movingInd-1],towerlist[movingInd],"fixwire");
						var rightCurve = DisplayFawCurve4(towerlist[movingInd],towerlist[movingInd+1],"fixwire");
						console.log("left,right",leftCurve,rightCurve);
						if(leftCurve[0]!=undefined){FawCurveGroup.children.splice((movingInd-1)*3,3,leftCurve[0],leftCurve[1],leftCurve[2]);}

						if(rightCurve[0]!=undefined){FawCurveGroup.children.splice((movingInd)*3,3,rightCurve[0],rightCurve[1],rightCurve[2]);}
					}
					else if(movingInd==0){
						var rightCurve = DisplayFawCurve4(towerlist[movingInd],towerlist[movingInd+1],"fixwire");
						console.log("rightCurve",rightCurve);
						if(rightCurve[0]!=undefined){FawCurveGroup.children.splice((movingInd)*3,3,rightCurve[0],rightCurve[1],rightCurve[2]);}
					}
					else if(movingInd==towerlist.length-1){
						var leftCurve = DisplayFawCurve4(towerlist[movingInd-1],towerlist[movingInd],"fixwire");
						console.log("leftCurve",leftCurve);
						if(leftCurve[0]!=undefined){FawCurveGroup.children.splice((movingInd-1)*3,3,leftCurve[0],leftCurve[1],leftCurve[2]);}
					}
					document.removeEventListener("mousemove",TowerMovingMove);
				}
			}
			if (event.button === 2){
				clearTempTow();
				clearTempTow();
				document.body.style.cursor = "default";
				scene.remove(scene.getObjectByName('tower'));
				document.removeEventListener("mousemove",TowerMovingMove);
				document.removeEventListener("mousedown",TowerMovingDown);
				console.log("rightbuttondown",scene);
			}
		}
	//升高杆塔
	function riseTower(event){
		document.body.style.cursor = "url(./css/rise.ico) 9 9, default";
		if (event.button === 0) {
			var riseInd = getIntersectsObject(event);
			//if return = -1
			let tempTowerHei;
			if(riseInd!=-1){tempTowerHei=towerlist[riseInd].TowerHigh;}else return;
			let tpos = TowerGroup.children[riseInd].position;
			let towerIndex = TowerPRKIndex(prk,towerlist[riseInd].TowerType);
			console.log("towerIndex");console.log(towerIndex,prk.TOWER[towerIndex]);
			if(towerlist[riseInd].TowerHigh< prk.TOWER[towerIndex].EndHigh){
				 tempTowerHei = towerlist[riseInd].TowerHigh + prk.TOWER[towerIndex].Dhigh;
				 console.log("tempTowerHigh");console.log(tempTowerHei);
				TowerGroup.children[riseInd]=createTower(TowerGroup.children[riseInd].position,
						towerlist[riseInd].Name,
						towerlist[riseInd].TowerType,
						towerlist[riseInd].Status,
						tempTowerHei,
						-1  //no need to push new tower to towerlist
				);
			}
			//TowerScriptGroup.children[riseInd]=createSpritelabel();

			console.log("output scene");console.log(scene);
			//find towerlist index and change this

			towerlist[riseInd].TowerHigh = tempTowerHei

			ComputeHugeHigh();

			TowerScriptGroup.children[riseInd] = createSpritelabel(towerlist[riseInd].Name,
					"Lh:"+towerlist[riseInd].Lh.toFixed(0)+"/Lv:"+towerlist[riseInd].Lv.toFixed(0)+
					"/Kv:"+(towerlist[riseInd].Lv.toFixed(0)/towerlist[riseInd].Lh.toFixed(0)).toFixed(2),
					towerlist[riseInd].TowerType+"-"+towerlist[riseInd].TowerHigh,
					"#000000",150,0,tpos.x,tpos.y+towerlist[riseInd].TowerHigh/ydivision*Gridsize+5,0);

			if(riseInd>0){
				var leftCurve = DisplayFawCurve4(towerlist[riseInd-1],towerlist[riseInd],"fixwire");
				FawCurveGroup.children[(riseInd-1)*3] = leftCurve[0];
				FawCurveGroup.children[(riseInd-1)*3+1] = leftCurve[1];
				FawCurveGroup.children[(riseInd-1)*3+2] = leftCurve[2];
				console.log(leftCurve);
			}
			if(riseInd<towerlist.length){
				var rightCurve = DisplayFawCurve4(towerlist[riseInd],towerlist[riseInd+1],"fixwire");
				FawCurveGroup.children[(riseInd)*3] = rightCurve[0];
				FawCurveGroup.children[(riseInd)*3+1] = rightCurve[1];
				FawCurveGroup.children[(riseInd)*3+2] = rightCurve[2];
				console.log(rightCurve);
			}
			

			console.log(towerlist);
			towerlist_tabledata = towerlist;
			console.log(towerlist_tabledata);
			GridManager.setAjaxData(towerlist_tableId, {"data": towerlist_tabledata});
			GridManager.refreshGrid(towerlist_tableId);
		}
		if (event.button === 2){
			document.body.style.cursor = "default";
			document.removeEventListener("mousedown",riseTower);
		}
	}
	//降低杆塔
	function fallTower(event){
			document.body.style.cursor = "url(./css/fall.ico) 9 9, default";
			if (event.button === 0) {
				var fallInd = getIntersectsObject(event);
				let tempTowerHei;
				if(fallInd!=-1){tempTowerHei=towerlist[fallInd].TowerHigh;}else return;
				let tpos = TowerGroup.children[fallInd].position;
				let towerIndex = TowerPRKIndex(prk,towerlist[fallInd].TowerType);
				console.log("towerIndex");console.log(towerIndex,prk.TOWER[towerIndex]);
				if(towerlist[fallInd].TowerHigh> prk.TOWER[towerIndex].StartHigh){
					tempTowerHei = towerlist[fallInd].TowerHigh - prk.TOWER[towerIndex].Dhigh;
					console.log("tempTowerHigh");console.log(tempTowerHei);
					TowerGroup.children[fallInd]=createTower(TowerGroup.children[fallInd].position,
							towerlist[fallInd].Name,
							towerlist[fallInd].TowerType,
							towerlist[fallInd].Status,
							tempTowerHei,
							-1  //no need to push new tower to towerlist
					);
				}
				//find towerlist index and change this


				towerlist[fallInd].TowerHigh = tempTowerHei

				ComputeHugeHigh();
				TowerScriptGroup.children[fallInd] = createSpritelabel(towerlist[fallInd].Name,
						"Lh:"+towerlist[fallInd].Lh.toFixed(0)+"/Lv:"+towerlist[fallInd].Lv.toFixed(0)+
						"/Kv:"+(towerlist[fallInd].Lv.toFixed(0)/towerlist[fallInd].Lh.toFixed(0)).toFixed(2),
						towerlist[fallInd].TowerType+"-"+towerlist[fallInd].TowerHigh,
						"#000000",150,0,tpos.x,tpos.y+towerlist[fallInd].TowerHigh/ydivision*Gridsize+5,0);




				if(fallInd>0){
					var leftCurve = DisplayFawCurve4(towerlist[fallInd-1],towerlist[fallInd],"fixwire");
					FawCurveGroup.children[(fallInd-1)*3] = leftCurve[0];
					FawCurveGroup.children[(fallInd-1)*3+1] = leftCurve[1];
					FawCurveGroup.children[(fallInd-1)*3+2] = leftCurve[2];
					console.log(leftCurve);
				}
				if(fallInd<towerlist.length){
					var rightCurve = DisplayFawCurve4(towerlist[fallInd],towerlist[fallInd+1],"fixwire");
					FawCurveGroup.children[(fallInd)*3] = rightCurve[0];
					FawCurveGroup.children[(fallInd)*3+1] = rightCurve[1];
					FawCurveGroup.children[(fallInd)*3+2] = rightCurve[2];
					console.log(rightCurve);
				}

				console.log(towerlist);
				towerlist_tabledata = towerlist;
				console.log(towerlist_tabledata);
				GridManager.setAjaxData(towerlist_tableId, {"data": towerlist_tabledata});
				GridManager.refreshGrid(towerlist_tableId);
			}
			if (event.button === 2){
				document.body.style.cursor = "default";
				document.removeEventListener("mousedown",fallTower);
			}
		}
	//修改杆塔
	function editTower(event){
		if (event.button === 0) {
		var editInd = getIntersectsObject(event);
		layer.getChildFrame('body',tpIndex).find("#editInd").val(editInd);
		if(editInd!=-1){
			console.log("selectedtower",editInd);
			//layer.close(tpIndex);
			//bindTowerPlace('修改杆塔信息',editInd);

			layer.getChildFrame('body',tpIndex).find("#towId")[0].value=towerlist[editInd].Name;
			layer.getChildFrame('body',tpIndex).find("#dis")[0].value=towerlist[editInd].Distance.toFixed(2);
			layer.getChildFrame('body',tpIndex).find("#hei")[0].value=towerlist[editInd].High.toFixed(2);
			layer.getChildFrame('body',tpIndex).find("#gap")[0].value=towerlist[editInd].offset;
			console.log(layer.getChildFrame('body',tpIndex).find('input[type=radio][name = towType]'));
			let St=layer.getChildFrame('body',tpIndex).find('input[type=radio]');
			console.log("ST");console.log(St);
			if(towerlist[editInd].Status==0){$(St[0]).prop('checked',true);}

			else if(towerlist[editInd].Status==3){$(St[2]).prop('checked',true);}
			else{$(St[1]).prop('checked',true);}
			layer.getChildFrame('body',tpIndex).find("#TowerType").empty();
			if(prk.TOWER!=undefined){
				for (let i = 0; i < prk.TOWER.length; i++) { //DJCS omit
					if(prk.TOWER[i].type==towerlist[editInd].Status){layer.getChildFrame('body',tpIndex).find("#TowerType").append("<option value='"+i+"'>"+prk.TOWER[i].Name+"</option>")};
				}
			}
			var selectindex = TowerPRKIndex(prk,towerlist[editInd].TowerType);
			console.log("selectindex");console.log(selectindex);
			layer.getChildFrame('body',tpIndex).find("#towerheight").empty();
			for (let i = prk.TOWER[selectindex].StartHigh;i<=prk.TOWER[selectindex].EndHigh;i=i+prk.TOWER[selectindex].Dhigh){
				layer.getChildFrame('body',tpIndex).find("#towerheight").append("<option value='"+i+"'>"+i+"</option>");
			}
			console.log(layer.getChildFrame('body',tpIndex).find("#towerheight"));
			//console.log(layer.getChildFrame('body',tpIndex).find("#TowerType option[text='"+towerlist[editInd].TowerType+"']"));
			layer.getChildFrame('body',tpIndex).find("#TowerType option:contains('"+towerlist[editInd].TowerType+"')").attr("selected",true);
			layer.getChildFrame('body',tpIndex).find("#towerheight").val(towerlist[editInd].TowerHigh);
			//bind select option setting
			layer.getChildFrame('body',tpIndex).find("#pilelist").empty();
			for (let i = 0; i < pile_tabledata.length; i++) {
				layer.getChildFrame('body',tpIndex).find("#pilelist").append("<option value='"+i+"'>"+pile_tabledata[i].name+"</option>");
			}
			layer.getChildFrame('body',tpIndex).find("#pilelist option:contains('"+towerlist[editInd].Position+"')").attr("selected",true);
			//Status;

		}else return;
		$("#towerset").mouseover(function () {
			console.log("鼠标进入")
			document.removeEventListener('mousedown', editTower);
		})
		$("#towerset").mouseout(function () {
			document.addEventListener('mousedown', editTower);
		})

		}
		if (event.button === 2){
			document.body.style.cursor = "default";
			document.removeEventListener("mousedown",editTower);
		}
	}

	window.editTowerSave=function(editInd){
		//update towerlist
		towerlist[editInd].Name = layer.getChildFrame('body',tpIndex).find("#towId")[0].value;
		towerlist[editInd].Distance = Number(layer.getChildFrame('body',tpIndex).find("#dis")[0].value);
		towerlist[editInd].High = Number(layer.getChildFrame('body',tpIndex).find("#hei")[0].value);
		towerlist[editInd].offset = Number(layer.getChildFrame('body',tpIndex).find("#gap")[0].value);
		towerlist[editInd].TowerType = layer.getChildFrame('body',tpIndex).find("#TowerType").find("option:selected").text();
		towerlist[editInd].Status = Number(layer.getChildFrame('body',tpIndex).find("input[type='radio']:checked").val());
		towerlist[editInd].TowerHigh = Number(layer.getChildFrame('body',tpIndex).find("#towerheight").find("option:selected").val());
		console.log(towerlist[editInd]);
		var tpos={};
		tpos.x = (towerlist[editInd].Distance-xMin)/xdivision*Gridsize;
		tpos.y = (towerlist[editInd].High - yMin)/ydivision*Gridsize;
		tpos.z = 0;

		//change towerstyle and towerscript
		TowerGroup.children[editInd]=createTower(tpos,
			towerlist[editInd].Name,
			towerlist[editInd].TowerType,
			towerlist[editInd].Status,
			towerlist[editInd].TowerHigh,
			-1  //no need to push new tower to towerlist
		);

		ComputeHugeHigh();
		TowerScriptGroup.children[editInd] = createSpritelabel(towerlist[editInd].Name,
				"Lh:"+towerlist[editInd].Lh.toFixed(0)+"/Lv:"+towerlist[editInd].Lv.toFixed(0)+
				"/Kv:"+(towerlist[editInd].Lv.toFixed(0)/towerlist[editInd].Lh.toFixed(0)).toFixed(2),
				towerlist[editInd].TowerType+"-"+towerlist[editInd].TowerHigh,
				"#000000",150,0,tpos.x,tpos.y+towerlist[editInd].TowerHigh/ydivision*Gridsize+5,0);

		//change displayfawcurve
		console.log(FawCurveGroup);
		console.log(towerlist);


		if(editInd>0){
			var leftCurve = DisplayFawCurve4(towerlist[editInd-1],towerlist[editInd],"fixwire");
			FawCurveGroup.children[(editInd-1)*3] = leftCurve[0];
			FawCurveGroup.children[(editInd-1)*3+1] = leftCurve[1];
			FawCurveGroup.children[(editInd-1)*3+2] = leftCurve[2];
			console.log(leftCurve);
		}
		if(editInd<towerlist.length){
			var rightCurve = DisplayFawCurve4(towerlist[editInd],towerlist[editInd+1],"fixwire");
			FawCurveGroup.children[(editInd)*3] = rightCurve[0];
			FawCurveGroup.children[(editInd)*3+1] = rightCurve[1];
			FawCurveGroup.children[(editInd)*3+2] = rightCurve[2];
			console.log(rightCurve);
		}
		console.log("after");
		console.log(FawCurveGroup);

	}

		/*    鼠标缩放移动事件     */
	function onDocumentMouseWheel(event) {
			let factor = 60;
			//从鼠标位置转化为webgl屏幕坐标位置
			mainCanvas = document.querySelector("#iframe_box canvas");
			let glScreenX = ((event.clientX  - mainCanvas.getBoundingClientRect().left)/ mainCanvas.offsetWidth) * 2 - 1;
			let glScreenY = -((event.clientY - mainCanvas.getBoundingClientRect().top)/ mainCanvas.offsetHeight) * 2 + 1;
			let vector = new THREE.Vector3(glScreenX, glScreenY, 0);
			//从屏幕向量转为3d空间向量
			vector.unproject(camera);
			let target = new THREE.Vector3(0, 0, 0);
			//相机偏移量
			vector.sub(camera.position).setLength(factor);
			if (event.deltaY < 0) {
				camera.position.add(vector);
				target.add(vector);
			} else {
				camera.position.sub( vector);
				target.sub(vector);
			}

			cameraX = camera.position.x;
			cameraY = camera.position.y;
			cameraZ = camera.position.z;

			camera.updateProjectionMatrix();
			renderer.render(scene, camera);
			labelRenderer.render( scene, camera );
		}

	function onDocumentMouseDown(event) {
			if (event.button != 1) return;
			event.preventDefault();
			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('mouseup', onDocumentMouseUp, false);
		}

	function onDocumentMouseMove(event) {
			var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
			var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
			cameraX -= movementX * 0.5;
			sceneX -= movementX * 0.5;
			cameraY += movementY * 0.5;
			sceneY += movementY * 0.5;
			cameraZ = camera.position.z;

			camera.position.set(cameraX, cameraY, cameraZ);
			// camera.lookAt(sceneX, sceneY, sceneZ);
			camera.updateProjectionMatrix();
			renderer.render(scene, camera);
			labelRenderer.render( scene, camera );
		}

	function onDocumentMouseUp(event) {
		document.removeEventListener('mousemove', onDocumentMouseMove);
		document.removeEventListener('mouseup', onDocumentMouseUp);
	}

	let selectedObj = null;
	let selectedPoint = null;

	function onDocumentSelected(event) {
		event.preventDefault();
		if (selectedObj) {
			console.log("selected");
			console.log(selectedObj);
			if(selectedObj.material.color==selectedObj.parent.children[0].material.color){
				selectedObj.material=selectedObj.parent.children[1].material;
			}
			else{
				selectedObj.material=selectedObj.parent.children[0].material;
			};

			selectedObj=null;
		}
		for(let i=0;i<scene.children.length;i++){
			if(scene.children[i].name =="redpoint"){
				console.log("name =redpoint");
				scene.remove(scene.children[i]);
			}
		}
		// console.log("clear redpoint");
		// console.log(scene.children);
		if(selectedPoint){
			console.log("change visiual");
			console.log(selectedPoint);
			selectedPoint.visible = false;
			selectedPoint = null;
		}
		const intersects = getIntersectsMapObj(event);

		if(intersects==undefined) return ;
		const coord_inter =getIntersects(event);
		if (intersects.length > 0) {
			const res = intersects.filter(function (res) {
				return res && res.object;
			})[0];
			console.log("res,resobj");
			console.log(res && res.object);
			if (res && res.object) {
				selectedObj = res.object;
				selectedObj.material = new THREE.LineBasicMaterial({color: 0xFF0011});
			}
		}
		//section redpoint caught
		for(let i=0;i<DEM_pgroup.children.length;i++){
			var num = scene.children.length;
			for(let j=0;j<DEM_pgroup.children[i].geometry.vertices.length;j++){
				if(Math.abs(DEM_pgroup.children[i].geometry.vertices[j].x-coord_inter.x)<0.5&&Math.abs(DEM_pgroup.children[i].geometry.vertices[j].y-coord_inter.y)<0.5){
					selectedPoint = DEM_pgroup.children[i];
					selectedPoint.visible =true;
					//create point;
					var red = new THREE.Geometry();
					red.vertices.push(new THREE.Vector3(DEM_pgroup.children[i].geometry.vertices[j].x,DEM_pgroup.children[i].geometry.vertices[j].y,0));
					var redmaterial= new THREE.PointsMaterial({color:0xff0000,size:2.0});
					var redpoint =new THREE.Points(red,redmaterial);
					redpoint.name="redpoint";
					redpoint.userData={"dem":selectedObj.name,"j":j};
					scene.add(redpoint);
					break;
				}

			}

			if(scene.children.length!=num){console.log(scene.children.length);break;}
		}

		//crossObject redPoint caught

		for(let i=0;i<scene.children.length;i++){
			var num = scene.children.length;
			if(scene.children[i].name == "crossObject"){
				var redcross = scene.children[i];
				if(redcross.children[1].geometry.attributes.position.array!= undefined&&
						redcross.children[2].geometry.attributes.position.array!= undefined){
					var target1 =  redcross.children[1].geometry.attributes.position.array;
					var target2 =  redcross.children[2].geometry.attributes.position.array;
				}
				for(let j = 0 ; j< target1.length/3;j=j+1){
					if((Math.abs(target1[3*j]-coord_inter.x)<0.5&&Math.abs(target1[3*j+1]-coord_inter.y)<0.5)||
							(Math.abs(target2[3*j]-coord_inter.x)<0.5&&Math.abs(target2[3*j+1]-coord_inter.y)<0.5)){
						var red = new THREE.Geometry();
						red.vertices.push(new THREE.Vector3(target2[3*j],target2[3*j+1],0));
						red.vertices.push(new THREE.Vector3(target1[3*j],target1[3*j+1],0));
						var redmaterial= new THREE.PointsMaterial({color:0xff0000,size:5.0});
						var redpoint =new THREE.Points(red,redmaterial);
						redpoint.name="redpoint";
						redpoint.userData={"dem":redcross.children[0].name,"j":j}; //output offset y
						scene.add(redpoint);
						break;
					}
				}

			}
		}


	}

	function getIntersectsMapObj(event){

		if(mainCanvas==null) return undefined;
		mouse.x = ((event.clientX  - mainCanvas.getBoundingClientRect().left)/ mainCanvas.offsetWidth) * 2 - 1;
		mouse.y = -((event.clientY - mainCanvas.getBoundingClientRect().top)/ mainCanvas.offsetHeight) * 2 + 1;
		const mouseVector = new THREE.Vector3();
		mouseVector.set(mouse.x,mouse.y,0.5);
		raycaster.setFromCamera(mouseVector,camera);
		// raycaster.intersectObjects(m_linegroup.children,true);
		// raycaster.intersectObjects(r_linegroup.children,true);
		// raycaster.intersectObjects(l_linegroup.children,true);
		var obj = new Array();
		if(raycaster.intersectObjects(m_linegroup.children,true)[0]!=undefined){obj.push(raycaster.intersectObjects(m_linegroup.children,true)[0]);}
		if(raycaster.intersectObjects(l_linegroup.children,true)[0]!=undefined){obj.push(raycaster.intersectObjects(l_linegroup.children,true)[0]);}
		if(raycaster.intersectObjects(r_linegroup.children,true)[0]!=undefined){obj.push(raycaster.intersectObjects(r_linegroup.children,true)[0]);}
		// crossobject can be caught
		// console.log("raycastScene",scene.children);
		// for(let i = 0;i<scene.children.length;i++){
		// 	if(scene.children[i].name == "crossObject"){
		// 		console.log(scene.children[i])
		// 		if(raycaster.intersectObject(scene.children[i].children[1],true)!=[]){
		// 			obj.push(raycaster.intersectObject(scene.children[i].children[1],true));
		// 		}
		// 	}
		// }
		//
		// console.log(obj);
		return obj;
	}


	/* 窗口自动适应 */
	function onWindowResize() {
		camera.aspect = canvasdiv.offsetWidth / canvasdiv.offsetHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(canvasdiv.offsetWidth, canvasdiv.offsetHeight);
		labelRenderer.setSize(canvasdiv.offsetWidth, canvasdiv.offsetHeight );
	}
	/*bottom Status bar*/
	function onDocumentMsg(event){
		var coord = getIntersects(event);

		var redpoint;
		if(coord!=undefined) {
			//console.log("x,z",coord.x,coord.y);
			for (let i = 0; i < scene.children.length; i++) {
				if (scene.children[i].name == "redpoint") {
					redpoint = scene.children[i];
					break;
				}
			}
			window.document.getElementById("footermsg").textContent = "		累距：" + (coord.x/Gridsize*xdivision+xMin).toFixed(2) + "	 高程: " + (coord.y/Gridsize*ydivision + yMin).toFixed(2);
			if(redpoint!=undefined){window.document.getElementById("footermsg").textContent = redpoint.userData.dem + "第" + redpoint.userData.j + "点，" +
					"坐标" + (redpoint.geometry.vertices[0].x/Gridsize*xdivision+xMin).toFixed(2) + "," + (redpoint.geometry.vertices[0].y/Gridsize*ydivision+yMin).toFixed(2)+
					"		累距：" + (coord.x/Gridsize*xdivision+xMin).toFixed(2) + "	 高程: " + (coord.y/Gridsize*ydivision + yMin).toFixed(2) +
					"			Δx:	" + ((coord.x - redpoint.geometry.vertices[0].x)/Gridsize*xdivision).toFixed(2) +
					"	Δz:	" + ((coord.y - redpoint.geometry.vertices[0].y)/Gridsize*ydivision).toFixed(2);     // coordination convert
			}
		}
	}
	/*function ablout Cross Object*/
	var GroundVertice = [];
	var pCount = 0;

	window.createGroundObj = function(event){
			if(event.button === 0){
				console.log("left button");
				mouse.x = ((event.clientX  - mainCanvas.getBoundingClientRect().left)/ mainCanvas.offsetWidth) * 2 - 1;
				mouse.y = -((event.clientY - mainCanvas.getBoundingClientRect().top)/ mainCanvas.offsetHeight) * 2 + 1;
				let pos = getIntersects(event);
				GroundVertice.push(pos);
				pCount++;
				console.log(scene.children[scene.children.length-1]);
				scene.children[scene.children.length-1].children[0].geometry.attributes.position.needsUpdate = true;
				scene.children[scene.children.length-1].children[0].geometry.setFromPoints(GroundVertice);
				scene.children[scene.children.length-1].children[0].geometry.setDrawRange(0, pCount);
				scene.children[scene.children.length-1].children[0].geometry.computeBoundingSphere();    //children Line ;


				//console.log(GroundVertice);
				console.log("pCount",scene,pCount);
			}
			if(event.button ===2){
				console.log("right button");

				scene.children[scene.children.length-1].children[0].geometry.setDrawRange(0, pCount);
				scene.children[scene.children.length-1].children[0].geometry.computeBoundingSphere();
				document.removeEventListener('mousemove',window.trackGroundObj);
				document.removeEventListener('mousedown',window.createGroundObj);
				//弹出框选择跨越
				if(pCount>1) {  //pCount无法产生实体
					layer.open({
						type:2,
						title:'选择跨越杆型',
						area:['250px','400px'],
						maxmin:true,
						content:'./html/CrossTower.html',
						//shade:0,

						success:function (layero,index) {
							console.log(layero,index);
							var body = layer.getChildFrame('body',index);
							console.log(body);
						}
					})
				}
				else { GroundVertice=[];pCount = 0;}
			}
		}

	window.trackGroundObj = function(event) {
			mouse.x = ((event.clientX - mainCanvas.getBoundingClientRect().left) / mainCanvas.offsetWidth) * 2 - 1;
			mouse.y = -((event.clientY - mainCanvas.getBoundingClientRect().top) / mainCanvas.offsetHeight) * 2 + 1;
			let pos = getIntersects(event);
			if(pCount!=0){
				GroundVertice[pCount]=pos ;
			}
			scene.children[scene.children.length-1].children[0].geometry.attributes.position.needsUpdate = true;
			scene.children[scene.children.length-1].children[0].geometry.setFromPoints(GroundVertice);
			scene.children[scene.children.length-1].children[0].geometry.setDrawRange(0, pCount+1);

			renderer.render(scene,camera);
		}

	window.createGroundCross = function (crossPoint,crossAttrName){
		var Cross_geo = new THREE.BufferGeometry().setFromPoints( crossPoint );
		var Cross_geop = new THREE.BufferGeometry().setFromPoints( crossPoint );
		var Cross_geosp = new THREE.BufferGeometry();
		var Cross_mat = new THREE.LineBasicMaterial( { color: 0x0000ff } );
		var Cross_matp = new THREE.PointsMaterial( { color: 0x888888,size:5 } );
		var Cross_line = new THREE.Line(Cross_geo,Cross_mat);
		var Cross_Point = new THREE.Points(Cross_geop,Cross_matp);
		var Section_Point = new THREE.Points(Cross_geosp,Cross_matp);  //Section_Point
		Cross_line.name = crossAttrName;
		let GroundGroup = new THREE.Group();
		GroundGroup.name = "crossObject"
		GroundGroup.add(Cross_line);
		GroundGroup.add(Cross_Point)
		GroundGroup.add(Section_Point);
		scene.add(GroundGroup);
	}

	window.createCrossLabel = function (towerhigh,codeId,added){
		var ray = new THREE.Raycaster();
		ray.set(new THREE.Vector3(-10,mp.m_Frame[7]-mp.m_Frame[14],0),new THREE.Vector3(1,0,0));   //-90 need to be set as mp.m_Frame[]
		ray.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 0.1 },
			Sprite: {}
		};
		var renewp = [];  var secp=[]; var arr=[]
		var target = ray.intersectObject(scene.children[scene.children.length-1].children[0]);   // children[0] line   children[1] points  children[2] section p

		console.log("intersect_result",target);
		// caculateDem intersect points and generate obj add to scene
		for(let i=0 ;i<target.length;i++){
			var sectionRay = new THREE.Raycaster();
			sectionRay.set(target[i].point,new THREE.Vector3(0,1,0));
			var m_linetarget = sectionRay.intersectObject(m_linegroup,true);
			for(let j=0;j<m_linetarget.length;j++){
				if(Math.abs(m_linetarget[j].point.x- target[i].point.x)<0.001){
				const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
				const points = [];
				points.push( target[i].point );
				points.push( m_linetarget[j].point );


				const geometry = new THREE.BufferGeometry().setFromPoints( points );
				const line = new THREE.Line( geometry, material );
				const pline2 = []; pline2.push(m_linetarget[j].point);
				pline2.push(new THREE.Vector3(m_linetarget[j].point.x,
						m_linetarget[j].point.y+towerhigh/ydivision*Gridsize,
						m_linetarget[j].point.z));

				const line2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pline2),
					new THREE.LineDashedMaterial( {
					color: 0x00ff00,
					linewidth: 1,
					scale: 1,
					dashSize: 3,
					gapSize: 1,
				} ));     //跨越杆高 towerHigh 虚线
					line2.computeLineDistances();  //for DashedMaterial
					line2.name =  codeId;
				let high = m_linetarget[j].point.y/20*ydivision+yMin+towerhigh;
				let sumD = ((target[i].point.x/20) - parseInt((target[i].point.x/20)))*xdivision;
				var cross_notehigh = createSprite(high.toFixed(2),"#000000",10,20,target[i].point.x+5,mp.m_Frame[13]-mp.m_Frame[14],Math.PI/2);
				var cross_notesumD = createSprite(sumD.toFixed(0),"#000000",20,20,target[i].point.x+5,mp.m_Frame[11]-mp.m_Frame[14]+10,Math.PI/2);
				var cross_note = createSprite(target[i].object.name,"#000000",10,20,target[i].point.x+5,mp.m_Frame[12]-mp.m_Frame[14],Math.PI/2);
				scene.children[scene.children.length-1].add(cross_note);
				scene.children[scene.children.length-1].add(cross_notehigh);
				scene.children[scene.children.length-1].add(cross_notesumD);
				scene.children[scene.children.length-1].add(line);
				scene.children[scene.children.length-1].add(line2);
				}
			}
		}

		//add intersect point and sectionPoint  (Update pointset)
		//draw Range point Vector get
		if(!added){    //draw or file open  mode:open GroundVertice empty and need to added line points
			let lineArray =scene.children[scene.children.length-1].children[0].geometry.attributes.position.array;
			scene.children[scene.children.length-1].children[0].geometry.setDrawRange(0, lineArray.length/3);
			for(let i = 0;i<lineArray.length/3;i++){
				let temp = new THREE.Vector3(lineArray[i*3],lineArray[i*3+1],lineArray[i*3+2]);
				renewp.push(temp);
			}
		}
		else {
			renewp = GroundVertice;
			renewp.pop();
		}


		// for(let i = 0 ;i<target.length;i++){
		// 	renewp.push(target[i].point);
		// }
		//renewp sort   cross point insert
		//renewp.sort(compare('x'));

		console.log("target ",target)
		let flag= 0;
		for (let i = 0; i < target.length; i++) {
			for (let j = flag; j < renewp.length-1; j++) {
				if((renewp[j].y-target[i].point.y)*(renewp[j+1].y-target[i].point.y)<0){
					renewp.splice(j+1,0,target[i].point);
					flag=j+2;
					break;
				}
			}
		}
		console.log("renewPoint",renewp);   //renewp repeat;
		scene.children[scene.children.length-1].children[1].geometry.attributes.position.needsUpdate = true;
		scene.children[scene.children.length-1].children[1].geometry.setFromPoints(renewp);
		scene.children[scene.children.length-1].children[1].geometry.setDrawRange(0, renewp.length);
		scene.children[scene.children.length-1].children[1].geometry.computeBoundingSphere();    //group point;

		for(let i = 0 ;i<renewp.length;i++){
			var sectionRay = new THREE.Raycaster();
			sectionRay.set(renewp[i],new THREE.Vector3(0,1,0));
			var secp_target = sectionRay.intersectObject(m_linegroup,true);
			for(let j=0;j<secp_target.length;j++){
				if(Math.abs(secp_target[j].point.x- renewp[i].x)<0.0001) {
					secp.push(new THREE.Vector3(secp_target[j].point.x,
							secp_target[j].point.y+towerhigh/ydivision*Gridsize,
							secp_target[j].point.z));
				}
			}
		}
		//scene.children[scene.children.length-1].children[2].geometry.attributes.position.needsUpdate = true;
		scene.children[scene.children.length-1].children[2].geometry.setFromPoints(secp);
		scene.children[scene.children.length-1].children[2].geometry.setDrawRange(0, secp.length);
		scene.children[scene.children.length-1].children[2].geometry.computeBoundingSphere();    //section point;


		//add to crosspoint to the Cross array
		if(added) {
			let addCrossObj = scene.children[scene.children.length - 1];
			let CrossCount = addCrossObj.children[2].geometry.drawRange.count;
			let PointArray = addCrossObj.children[2].geometry.attributes.position.array;
			let ProjPointArray = addCrossObj.children[1].geometry.attributes.position.array;
			console.log("PointArray", PointArray);
			let CrossPoint = [];

			for (let i = 0; i < CrossCount; i++) {   //proj y=0  dc
				let temp = {
					"x": 0,
					"y": 0,
					"z": 0,
					"dc": 0,
					"towerHigh": 0
				};
				temp.x = PointArray[3 * i] / Gridsize * xdivision + xMin;
				temp.y = (ProjPointArray[3 * i + 1] - (mp.m_Frame[7] - mp.m_Frame[14])) / Gridsize * xdivision;
				temp.z = PointArray[3 * i + 1] / Gridsize * ydivision + yMin;
				if (temp.y == 0) {
					temp.dc = codeId;
				}
				temp.towerHigh = towerhigh;
				CrossPoint.push(temp);
			}
			console.log("addCrossObj", addCrossObj);
			let addCross = {
				"Attr": Number(addCrossObj.children[0].name.substring(1, 4)),
				"AttrEx": 0,
				"AttrName": addCrossObj.children[0].name,
				"PointCount": CrossCount,
				"CrossPoint": CrossPoint
			}
			cross.push(addCross);
			console.log("addedCross", cross);
			renderer.render(scene, camera);
			GroundVertice = [];
			pCount = 0;
		}
	}

	window.MapCrossDraw = function(cross,added){
		//delete original
		for(let i = 0 ;i<scene.children.length;i++){
			if(scene.children[i].name == "crossObject"){scene.remove(scene.children[i]);i=i-1;console.log(scene.children[i]);}
		}

		console.log("afterdeleteCrossObject",scene);
		console.log("cross",cross);
		for(let i=0;i<cross.length;i++){
			let crossPoint = [];
			let crossAttrName;
			for(let j=0;j<cross[i].PointCount;j++){
				if( cross[i].CrossPoint[j].y!=0){
					var temp = new THREE.Vector3();
					temp.x= (cross[i].CrossPoint[j].x-xMin)/xdivision*Gridsize;
					temp.y= cross[i].CrossPoint[j].y/xdivision*Gridsize+mp.m_Frame[7]-mp.m_Frame[14];
					temp.z= 0
					crossPoint.push(temp);
				}
			}
			crossAttrName = cross[i].AttrName;
			console.log("GroundGroundCross",crossPoint);
			createGroundCross(crossPoint,crossAttrName);
			//GroundVertice = crossPoint;
			let towerhigh=0;
			let codeId=0;
			for(let ii = 0;ii < cross[i].CrossPoint.length ;ii++){
				if(cross[i].CrossPoint[ii].dc>2000) {codeId = cross[i].CrossPoint[ii].dc;};
				if(cross[i].CrossPoint[ii].towerHigh>0&&cross[i].CrossPoint[ii].y ==0){towerhigh = cross[i].CrossPoint[ii].towerHigh;};
			}
			createCrossLabel(towerhigh,codeId,added);
		}

	}

	window.bindTowerPlace = function(title,editInd){
		console.log("title.",title);
		if(title != $(".layui-layer-title").text()){
			layer.close(tpIndex);
			layer.open({
				type:2,
				title: title,
				area:['250px','340px'],
				offset: ['200px', '200px'],
				maxmin:true,
				shadeClose:false,
				shade:0,
				content:'./html/TowerPlace.html',
				//id: title,
				success:function (layero,index) {
					var body = layer.getChildFrame('body',index);
					//mark the page
					tpIndex = index;
					//bind towId
					body.find("#towId")[0].value = "G"+towerlist.length;
					console.log("insert tlength ",body.find("#towId")[0].value,towerlist.length);
					//bind select option setting
					for (let i = 0; i < pile_tabledata.length; i++) {
						body.find("#pilelist").append("<option value='"+i+"'>"+pile_tabledata[i].name+"</option>");
					}
					// tower high option bind don't need to set fixed
					//console.log(body.find('input[type^=radio]'));
					console.log(body.find("input[type='radio']:checked").val());   //get checked value and set
					if(prk.TOWER!=undefined){
						for (let i = 0; i < prk.TOWER.length; i++) {
							if(prk.TOWER[i].type==0){body.find("#TowerType").append("<option value='"+i+"'>"+prk.TOWER[i].Name+"</option>")};
						}
					}
					var selectindex = body.find("#TowerType option:selected")[0].value;
					for (let i = prk.TOWER[selectindex].StartHigh;i<=prk.TOWER[selectindex].EndHigh;i=i+prk.TOWER[selectindex].Dhigh){
						body.find("#towerheight").append("<option value='"+i+"'>"+i+"</option>");
					}
					console.log(title);
					// if(title=='修改杆塔信息'){
					// 	layer.getChildFrame('body',tpIndex).find("#towId")[0].value=towerlist[editInd].Name;
					// 	layer.getChildFrame('body',tpIndex).find("#dis")[0].value=towerlist[editInd].Distance;
					// 	layer.getChildFrame('body',tpIndex).find("#hei")[0].value=towerlist[editInd].High;
					// 	layer.getChildFrame('body',tpIndex).find("#gap")[0].value=towerlist[editInd].offset;
					// 	console.log(layer.getChildFrame('body',tpIndex).find('input[type=radio][name = towType]'));
					// 	let St=layer.getChildFrame('body',tpIndex).find('input[type=radio]');
					// 	console.log("ST");console.log(St);
					// 	if(towerlist[editInd].Status==0){$(St[0]).prop('checked',true);}
					//
					// 	else if(towerlist[editInd].Status==3){$(St[2]).prop('checked',true);}
					// 	else{$(St[1]).prop('checked',true);}
					// 	layer.getChildFrame('body',tpIndex).find("#TowerType").empty();
					// 	if(prk.TOWER!=undefined){
					// 		for (let i = 0; i < prk.TOWER.length; i++) {
					// 			if(prk.TOWER[i].type==towerlist[editInd].Status){layer.getChildFrame('body',tpIndex).find("#TowerType").append("<option value='"+i+"'>"+prk.TOWER[i].Name+"</option>")};
					// 		}
					// 	}
					// 	var selectindex = TowerPRKIndex(prk,towerlist[editInd].TowerType);
					// 	console.log("selectindex");console.log(selectindex);
					// 	layer.getChildFrame('body',tpIndex).find("#towerheight").empty();
					// 	for (let i = prk.TOWER[selectindex].StartHigh;i<=prk.TOWER[selectindex].EndHigh;i=i+prk.TOWER[selectindex].Dhigh){
					// 		layer.getChildFrame('body',tpIndex).find("#towerheight").append("<option value='"+i+"'>"+i+"</option>");
					// 	}
					// 	console.log(layer.getChildFrame('body',tpIndex).find("#towerheight"));
					// 	//console.log(layer.getChildFrame('body',tpIndex).find("#TowerType option[text='"+towerlist[editInd].TowerType+"']"));
					// 	layer.getChildFrame('body',tpIndex).find("#TowerType option:contains('"+towerlist[editInd].TowerType+"')").attr("selected",true);
					// 	layer.getChildFrame('body',tpIndex).find("#towerheight").val(towerlist[editInd].TowerHigh);
					// 	//bind select option setting
					// 	for (let i = 0; i < pile_tabledata.length; i++) {
					// 		layer.getChildFrame('body',tpIndex).find("#pilelist").append("<option value='"+i+"'>"+pile_tabledata[i].name+"</option>");
					// 	}
					// 	layer.getChildFrame('body',tpIndex).find("#pilelist option:contains('"+towerlist[editInd].Position+"')").attr("selected",true);
					// 	//Status;
					// }

				}
			})
		}

	}

	window.TowerInfo = function(){
		return prk.TOWER;
	}

	/* 初始化 */
	function init() {
		initScene();
		initCamera();
		initRender();
		initLight();

		/* 事件监听 */
		document.addEventListener('mousewheel', onDocumentMouseWheel, false);//兼容ie chrome
		document.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false);//兼容火狐
		document.addEventListener('mousedown', onDocumentMouseDown, false);
		document.addEventListener('mousedown', onDocumentSelected, false);
		document.addEventListener('mousemove', onDocumentMsg, false);

		drawGeo(pile_tabledata);

		/*鼠标放置杆塔*/
		$("#putTower").click(function () {
			bindTowerPlace('前进方向排杆');
			document.body.style.cursor = "default";
			clearTempTow();
			document.removeEventListener('mousedown', towerDelete);
			document.removeEventListener('mousedown', riseTower);
			document.removeEventListener('mousedown', fallTower);
			document.removeEventListener('mousedown', TowerInsertDown);
			document.removeEventListener('mousedown', editTower);
			document.removeEventListener('mousedown', TowerMovingDown);
			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('mousedown', onMouseDown, false);

		})
		/*鼠标删除杆塔*/
		$("#deleteTower").click(function () {
			clearTempTow();
			document.removeEventListener('mousedown', onMouseDown);
			document.removeEventListener('mousedown', riseTower);
			document.removeEventListener('mousedown', fallTower);
			document.removeEventListener('mousedown', TowerInsertDown);
			document.removeEventListener('mousedown', editTower);
			document.removeEventListener('mousedown', TowerMovingDown);
			document.removeEventListener('mousemove', onMouseMove);
			document.body.style.cursor = "url(./css/cancel.ico) 9 9, default";
			document.addEventListener("mousedown",towerDelete,false);
		})
		/*鼠标插入杆塔*/
		$("#insertTower").click(function () {
			bindTowerPlace('插入杆塔');
			document.body.style.cursor = "default";
			clearTempTow();
			document.removeEventListener('mousedown', onMouseDown);
			document.removeEventListener('mousedown', riseTower);
			document.removeEventListener('mousedown', towerDelete);
			document.removeEventListener('mousedown', fallTower);
			document.removeEventListener('mousedown', editTower);
			document.addEventListener("mousedown",TowerInsertDown,false);

		})
		/* 鼠标移动杆塔 */
		$("#moveTower").click(function () {
			document.body.style.cursor = "crosshair";
			bindTowerPlace('移动杆塔');
			clearTempTow();
			document.removeEventListener('mousedown', towerDelete);
			document.removeEventListener('mousedown', onMouseDown);
			document.removeEventListener('mouseup', onDocumentMouseUp);
			document.removeEventListener('mousedown', TowerInsertDown);
			document.removeEventListener('mousedown', riseTower);
			document.removeEventListener('mousedown', fallTower);
			document.removeEventListener('mousedown', TowerInsertDown);
			document.removeEventListener('mousedown', editTower);
			document.removeEventListener('mousemove', onDocumentMouseMove);
			document.removeEventListener('mousemove', onMouseMove);
			document.addEventListener("mousedown",TowerMovingDown,false);
		 })
		/*鼠标升高杆塔*/
		$("#riseTower").click(function(){
			clearTempTow();
			document.removeEventListener('mousedown', onMouseDown);
			document.removeEventListener('mousedown', towerDelete);
			document.removeEventListener('mousedown', fallTower);
			document.removeEventListener('mousedown', TowerInsertDown);
			document.removeEventListener('mousedown', editTower);
			document.removeEventListener('mousedown', TowerMovingDown);
			document.removeEventListener('mousemove', onMouseMove);
			document.body.style.cursor = "url(./css/rise.ico) 9 9, default";
			document.addEventListener("mousedown",riseTower,false);
		})
		/*鼠标降低杆塔*/
		$("#fallTower").click(function(){
			clearTempTow();
			document.removeEventListener('mousedown', onMouseDown);
			document.removeEventListener('mousedown', towerDelete);
			document.removeEventListener('mousedown', riseTower);
			document.removeEventListener('mousedown', TowerInsertDown);
			document.removeEventListener('mousedown', editTower);
			document.removeEventListener('mousedown', TowerMovingDown);
			document.removeEventListener('mousemove', onMouseMove);
			document.body.style.cursor = "url(./css/fall.ico) 9 9, default";
			document.addEventListener("mousedown",fallTower,false);
		})
		/*修改杆塔*/
		$("#editTower").click(function () {
			document.body.style.cursor = "default";
			bindTowerPlace('修改杆塔信息');
			clearTempTow();
			document.removeEventListener('mousedown', onMouseDown);
			document.removeEventListener('mousedown', riseTower);
			document.removeEventListener('mousedown', towerDelete);
			document.removeEventListener('mousedown', fallTower);
			document.removeEventListener('mousedown', TowerInsertDown);
			document.removeEventListener('mousedown', TowerMovingDown);
			document.addEventListener("mousedown",editTower,false);
		})



		window.selectAttr = function(groundobj){  // create ground object and begin mouseEventListener

			//if last Cross_line is empty delete

			var lastLine = scene.children[scene.children.length-1].children[0];
			console.log("lastline",lastLine);
			console.log("SCENE",scene);
			if(lastLine !=undefined&&scene.children[scene.children.length-1].name=="crossObject"){
				if(lastLine.type==="Line"&&(lastLine.geometry.drawRange.count<2||lastLine.geometry.drawRange.count==Infinity)){
					console.log("removeGroup",scene.children[scene.children.length-1]);
					scene.remove(scene.children[scene.children.length-1]);
				}
			}
			
			console.log("SCENEAfter",scene,GroundVertice);
			createGroundCross(GroundVertice,groundobj.name);

			//add Listener
			document.addEventListener('mousedown', window.createGroundObj, false);
			document.addEventListener('mousemove', window.trackGroundObj, false);

			// create CrossObjGroup  store the information about the Cross_line; ?

			console.log("select add",scene.children);
			renderer.render( scene, camera );
		}


		window.addEventListener('resize', onWindowResize, false);


		document.oncontextmenu=blockContextmen;//关闭右键默认菜单
	}

	/* 循环调用 */
	function animate() {
		requestAnimationFrame(animate);
		renderer.render(scene, camera);
		labelRenderer.render( scene, camera );

	}
	/* 初始加载 */
	(function () {
		init();
		animate();
	})();

	}
</script>